<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN//2.0">
<HTML>
<HEAD>
<!-- Document generated by Thot -->
<TITLE>Appman-E</TITLE>
<LINK HREF="Appman.toc.html" REL="ToC">
</HEAD>
<BODY>
<PRE>
<EM>LibThot 2.1.a</EM></PRE>
<PRE>
Date: Draft - May 7, 1997</PRE>

<H1>The Thot Application Generation Language</H1>
<ADDRESS>Vincent Quint</ADDRESS>
<ADDRESS>Ir&egrave;ne Vatton</ADDRESS>
<CODE>INRIA<BR></CODE>

<HR>

<H2><A NAME="secta1">1</A> Principles</H2>

<P>The Thot application generation language enables applications based on the
<EM>active document</EM> concept. An active document is an electronic document
which transforms itself or acts on its computing environment when certain
editing commands are issued by the user. This concept is used to build
different types of applications including access to databases, user interface
construction and technical document processing.</P>

<P>The Thot application generation language is used to define a graphic
interface (a set of menus) to which the application designer can associate
functions. These functions are either Thot standard functions or new specific
functions.</P>

<P>The language and its associated mechanisms also allow application designers
to modify or extend standard Thot editing functions. The application can
receive control during the execution of a standard function, by asking for an
<EM>event</EM>. These events are also specified in the application generation
language.</P>

<P>Consequently, an application is constituted by two different sets of
functions:</P>

<UL>
<LI><I>Commands</I> are run when the user selects a menu item. These commands
can be standard commands provided by the Thot toolkit or new, specific
commands written by the application developer.
<LI><I>Actions</I> are run when certain events occur during standard editing
commands.
</UL>

<P> Commands and actions can use the Thot API  in order to modify the
documents being handled (refer to <I>The Thot Tool Kit API)</I></P>

<P>Application generation is based on <I>application schema</I>s written in a
specific language, the <EM>A language</EM>. Menus and associated specific
commands are declared in the main application schema, called
<TT>EDITOR.A</TT>. This application schema can refer to other application
schemas that define shared components reusable in different applications.
These application schemas are based on a generic logical structure and are
related to a structure schema. These application schemas have the same name as
the corresponding structure schema and the <TT>.A</TT> suffix.</P>

<H3><A NAME="sectb11">1.1</A> Menus and specific commands</H3>

<P>The <TT>EDITOR.A</TT> application schema defines the menus of the main
window (if this main window exists) and those attached to the menu bar of each
document window. The app application allows one to define different menus for
different document types (identified by their structure names). For a specific
document type, menus can differ form one view to another (the range in
presentation schema identified the view when the menu is specific to one
view).</P>

<P>The application schema associates a command with each item in these menus.
Each item is located within a menu or a cascade submenu of a menu. The cascade
is limited to one level. </P>

<P>When the user selects a menu item, the corresponding command is called,
with the current document and view as parameters.</P>

<P>There are different menu sections in the <TT>EDITOR.A</TT> application
schema:</P>

<UL>
<LI>The Main Window section is optional. It defines the menus attached to the
main window.
<LI>The Document Windows section is mandatory. It defines the menu bar of all
document windows.
<LI>The Structure_name Windows sections are optional. They specify the menu
bar for specific document types.
</UL>

<H3><A NAME="sectb12">1.2</A> Events and actions</H3>

<P>An event is raised by the editor whenever a Thot <EM>standard</EM> editing
command perform some treatment that the application needs to complement or
replace. For example, an event can be raised when the user selects an element,
modifies a character string, creates or deletes a logical element, associates
an attribute with an element, opens or closes a document view, saves a
document, etc.</P>

<P>Only standard editing commands raise events. <EM>Specific</EM> commands
associated with menu items in an application schema <EM>do not</EM> raise any
event. </P>

<P>Each event raised by Thot is associated with the object concerned by the
Thot editing command that triggers the event: element, attribute, view,
document, etc.</P>

<P>Whenever an event is raised, Thot calls the corresponding actions that is
associated with the event and the corresponding object in the application
schemas in use.</P>

<P>The user and the programs (commands and actions) can access the same
functions, but through different interfaces: standard Thot commands for the
user, API for programs. The operations performed on documents by an
application programs using the Thot API do not create events. However, there
are some exceptions to this rule; they are mentioned below.</P>

<P>The Thot standard editing commands generally produce two events with the
same name but with different suffixes:</P>

<UL>
<LI><EM>.Pre</EM>: this event is raised (and the action is executed) when the
standard command is called by the user, before being processed by the editor.
It allows the application to perform some processing, <I>before</I> the editor
executes the standard command <I>or instead of</I> the normal processing of
the editor. The action called in the application by the event returns a
boolean value to indicate whether or not the performed action replaces the
standard processing of the editor. If it is a replacement (<TT>True</TT> is
returned by the action), the editor does not perform the normal processing.
<LI><EM>.Post</EM>: this event is raised (and the action is executed)
<I>after</I> the editor has performed the standadrd command normally.
</UL>

<P>When an action performed on a <EM>.Pre</EM> event has replaced the normal
processing of the standard command, there is no corresponding <EM>.Pos</EM>t
event since the editor has not processed the command.</P>

<P>Each time an action of the application is called by an event, it receives a
context as a parameter, which allows the application to identify the
conditions in which the event has been raised. This context varies from an
event to the other because it only provides information significant for the
event in question.</P>

<P>Here is a list of all items that can be found in the context (for each
event, only a subset of this list is present):</P>

<UL>
<LI>the standard editing command which triggered the event (this information
is always present because it permits the identification of the event and it
determines the other items present in the context);
<LI>the document in question;
<LI>the element in question;
<LI>the element type in question;
<LI>the target element of the editing operation. It may be different from the
element in question, for instance in the case of a reference;
<LI>the type of the presentation rule in question;
<LI>the attribute in question;
<LI>the attribute type in question.
</UL>

<P>Section <A HREF="#secta5">5</A> lists all the events that can be raised,
with the name of the event, the parameters received by the action which
handles this event and the conditions in which it is raised.</P>

<H2><A NAME="secta2">2</A> The A language</H2>

<P>Application generation is based <I>application schema</I>s written in a
specific language, the <EM>A language</EM>. Menus and associated specific
commands are declared in the main application schema, <TT>EDITOR.A</TT>. This
application schema can refer to other application schemas related to different
structure schemas.</P>

<P>Any application schema starts with the <EM>APPLICATION</EM> keyword
followed by the <EM>EDITOR</EM> word or the structure schema name.</P>

<P>The main application schema of the application contains two sections that
do not appear in other application schemas.</P>

<UL>
<LI>The <EM>USES</EM> section appears just after the <EM>APPLICATION</EM>
statement. This section is optional and when it is present, it declares the
other structure schemas used by the application as well as the modules needed.
A module is a set of standard editing functions that each application may
decide to use or not.
<LI>The <EM>MENUS</EM> section is a mandatory section in the <TT>EDITOR.A</TT>
schema and appears at the end of the schema.
</UL>

<P>Three other sections can appear in any application schema:
<EM>DEFAULT</EM>, <EM>ELEMENTS</EM> and <EM>ATTRIBUTES</EM>. These sections
are optional but at least one of them must be present in an application schema
associated with a structure schema.</P>

<P>The schema must end with the <EM>END</EM> keyword.</P>

<PRE>
ASchema =         'APPLICATION' ElemIdent ';'
                  [ 'USES' SchemaAndModules ]
                  [ 'DEFAULT' EvtActionList ]
                  [ 'ELEMENTS' &lt; ElemActionList &gt; ]
                  [ 'ATTRIBUTES' &lt; AttrActionList &gt; ] 
                  [ 'MENUS' Menus ]
                  'END' .
</PRE>

<H3><A NAME="sectb21">2.1</A> Application integration</H3>

<P>A single application can use several application schemas: one per structure
schema for which specific commands or actions must be performed (for instance,
Report and Paragraph) and one general application schema (the EDITOR schema).
When an event is raised for a given element, the editor consults first the
application schema of the structure defining this element in order to check
whether an action has been attached to this event. If it is not the case, the
editor consults sequentially the application schemas of the parent elements
and finally the <TT>EDITOR</TT> application schema.</P>

<P>The <TT>EDITOR.A</TT> schema lists the names of other application schemas
involved in the application, in its USES section. The A compiler uses this
list to load the corresponding commands and actions.</P>

<P>The USES section lists also all the modules needed by the application.</P>

<PRE>
SchemasAndModules = SchemaOrModule &lt; ',' SchemaOrModule &gt; ';' .
SchemaOrModule    = DocumentType | Module .
</PRE>

<P>The Thot library provides optional modules which can be used or not by an
application. As an example, a document reader application does not need
editing functions. The USES section allows application developer to explicitly
load the needed Thot modules. The available modules are:</P>

<UL>
<LI>Editing: This module provides basic editing functions. It is automatically
loaded when at least one standard editing command is used in the MENUS section
(TtcCutSelection, etc.)
<LI>StructEditing: This module has to be loaded explicitly. It provides
restructuring functions and handles the Thot standard insertion menu.
<LI>StructSelect: This module has to be loaded explicitly. It provides a
structural selection instead of the standard one (no automatic replacement,
ability to select directly structured elements, etc.)
<LI>Search: This module provides search and replace functions. It is
automatically loaded when a Thot search command is used.
<LI>StructSearch: This module has to be loaded explicitly. It allows a
combination of structural search with textual search and replace.
<LI>Index: This module has to be loaded explicitly. It provides the Thot index
capability.
<LI>DisplayEmptyBox: This module has to be loaded explicitly. It displays
empty elements as grey rectangles.
<LI>Lookup: This module has to be loaded explicitly. It provides an
<TT>XLookupString</TT> function that allows users to insert composed
characters into Motif widget.
</UL>

<H3><A NAME="sectb22">2.2</A> Menus declaration</H3>

<P>The MENUS section defines the menus contituting a menu bar (see example in 
<A HREF="#secta7">7</A>):</P>

<UL>
<LI>The <TT>Main Window</TT> section is optional. It defines the menu bar of
the main window.
<LI>The <TT>Document Windows</TT> section is mandatory. It defines the menu
bar of all document windows.
<LI>The <TT><I>Structure_name</I></TT><TT> Windows</TT> sections are optional.
They specify the menu bar for specific document types.
</UL>
<PRE>
Menus =         [ 'Main' 'Window' ':' MenuList ]
                [ 'Document' 'Windows' ':' MenuList ]
                &lt; DocumentType 'Windows' ':' MenuList &gt; .
 
MenuList =      'BEGIN' NewMenu &lt; NewMenu &gt; 'END' ';' /
                NewMenu .
 
NewMenu =       [ 'view' ':' ViewNum ] MenuIdent
                [ '.' SubmenuIdent] [ ItemCascade ] ';' .
ItemCascade =   'Separator' / 'Button' ':' ItemAction /
                'Toggle' ':' ItemAction /
                'Dynamic' ':' ItemIdent .
ItemAction =    ItemIdent '-&gt;' ActionIdent .
 
DocumentType =  NAME .
MenuIdent =     NAME .
SubmenuIdent =  NAME .
ItemIdent =     NAME .
IdentAction =   NAME .
</PRE>

<P>For each menu item, the application schema associates a specific command,
except for the standard menus, composed by the Thot editor. For these menus
neither items nor actions have to be specified. There are two such menus:
"Attributes_" and  "Selection_".</P>

<P>The Thot toolkit allows application designers to declare one-level cascade
menus (menu and submenu).</P>

<P>A menu item can be:</P>

<UL>
<LI>a simple push button: "Button",
<LI>a toggle button: "Toggle",
<LI>a separator: "Separator" (there is no action in this case),
<LI>or a dynamic entry: "Dynamic" (allows dynamic extension of the dialogue).
</UL>

<P>The Thot toolkit is designed to support multilingual dialogue. Names of
menus, submenus and menu items declared in the application schema are
considered as generic names. When the application starts, the editor looks for
a dialogue table:
config/$LANG-'name'dialogue  ('name' represents the application name)
to substitute generic names by localized name adapted to the current language
$LANG.</P>

<P>The A compiler automatically generates a <TT>EDITORdialogue</TT> file that
can be used as a model to construct dialogue tables for each supported
language.</P>

<H3><A NAME="sectb23">2.3</A> <A NAME="L221">Associating actions with
events</A></H3>

<P>Actions that must be executed when certain events are raised, are specified
in sections <EM>DEFAULT</EM>, <EM>ELEMENTS</EM> and <EM>ATTRIBUTES</EM>.
Association of actions with events is simply expressed by the name of the
event (see the list of events in section <A HREF="#secta5">5</A>) followed by
an arrow (the two characters '-' and '&gt;') and the name of the action.</P>

<P>The name of the event contains the suffix <EM>.Pre</EM> or <EM>.Post</EM>
depending on whether the action must be performed before or after normal
processing by the editor. If no suffix is present the event is assumed to have
the <EM>.Pre</EM> suffix.</P>

<P>The name of the action is the name of the procedure written by the
programmer and called by the event.</P>

<PRE>
EvtAction =    EvtIdent [ '.' PostPre ] '-&gt;' ActionIdent ';' .
PostPre =      'Post' / 'Pre' .
EvtIdent =     NAME .
ActionIdent =  NAME .
</PRE>

<H3><A NAME="sectb24">2.4</A> Default actions</H3>

<P>The <EM>DEFAULT</EM> section includes the event/action associations which,
by default, apply to all element types and all the attributes defined in the
structure schema corresponding to the application schema.</P>

<P>For a given element type and for a given event, when the <EM>ELEMENTS</EM>
section does not contain an event/action association, the association of the
<EM>DEFAULT</EM> section is taken into account if it exits. The
<EM>DEFAULT</EM> section can be absent. It can also contain only a subset of
the events listed in section <A HREF="#secta5">5</A>. When the
<EM>ELEMENTS</EM> section for a given element type and the <EM>DEFAULT</EM>
section do not define any action for a given event, this event has no effect
for the elements of that type.</P>

<P>The same principle applies to attributes: the <EM>DEFAULT</EM> section
specifies the event/action associations which apply to all attributes for
which the <EM>ATTRIBUTE</EM> section does not include these events.</P>

<P>The <EM>DEFAULT</EM> section is composed of the <EM>DEFAULT</EM> keyword
followed by an event/action association, if there is a single default
association, or by a sequence of associations between the keywords
<STRONG>BEGIN</STRONG> and <STRONG>END</STRONG>, if there are several. The
<STRONG>END</STRONG> keyword must be followed by a semicolon. The event/action
associations can be either for element types (see section <A
HREF="#sectb25">2.5</A>) or for attributes (see section <A
HREF="#sectb26">2.6</A>). </P>

<PRE>
                 'DEFAULT' EvtActionList
EvtActionList =  EvtAction /
                 'BEGIN' EvtAction &lt; EvtAction &gt; 'END' ';' .
</PRE>

<H3><A NAME="sectb25">2.5</A> <A NAME="L317">Actions associated with
elements</A></H3>

<P>The actions to be called for elements of a given type are defined in the
<EM>ELEMENTS</EM> section. In this section, the name of each element type
requiring actions is followed by a colon and by the event/action association
to be applied (if there is only one) or the list of associations (if there are
several) between the keywords <STRONG>BEGIN</STRONG> and <STRONG>END</STRONG>.
The <STRONG>END</STRONG> keyword is followed by a semicolon.</P>

<P>In the case where the element type is a mark pair, but only in this case,
the type name can be preceded by the keywords <EM>First</EM> or
<EM>Second</EM>. These keywords indicate whether the associations that follow
apply to the first or second mark of the pair.</P>

<P>Each event/action association for an element type is composed in the same
way as described in section <A HREF="#sectb23">2.3</A>.</P>

<PRE>
                 'ELEMENTS' &lt; ElemActionList &gt;
ElemActionList = ElemActions &lt; ElemActions &gt; .
ElemActions =    [ FirstSec ] ElemIdent ':' EvtActionList .
FirstSec =       'First' / 'Second' .
ElemIdent =       NAME .
EvtActionList =   EvtAction /
                 'BEGIN' EvtAction &lt; EvtAction &gt; 'END' ';' .
</PRE>

<H3><A NAME="sectb26">2.6</A> <A NAME="L350">Actions associated with
attributes</A></H3>

<P>The actions to be called for given attributes are defined in the
<EM>ATTRIBUTES</EM> section. In this section, the name of each attribute
requiring actions is followed by a colon and by the event/action association
to be applied (if there is only one) or the list of associations (if there are
several) between the keywords <STRONG>BEGIN</STRONG> and <STRONG>END</STRONG>;
the <STRONG>END</STRONG> keyword is followed by a semicolon.</P>

<P>Each event/action association for an attribute is composed in the same way
as indicated in section <A HREF="#sectb23">2.3</A>, but only certain events
are allowed for attributes, those beginning with <EM>Attr</EM> (see section <A
HREF="#sectb51">5.1</A> for the definition of these events).</P>

<PRE>
                 'ATTRIBUTES' &lt; AttrActionList &gt;
AttrActionList = AttrActions &lt; AttrActions &gt; .
AttrActions =    AttrIdent ':' EvtActionList .
AttrIdent =      NAME .
</PRE>

<H2><A NAME="secta3">3</A> Thot standard commands</H2>

<P>The Thot toolkit provides a set of standard commands. The commands
parameters are always the document identification and the view number.</P>

<DL>
<DT>TtcChangeCharacters  (Document, View):</DT>

<DD>Display the form that allows user to change font family, character style
and character size.
</DL>

<DL>
<DT>TtcChangeColors  (Document, View):</DT>

<DD>Display the form that allows user to change background and foreground
colors.
</DL>

<DL>
<DT>TtcChangeFormat  (Document, View):</DT>

<DD>Display the form that allows user to change indentation, alignment,
justification and line spacing.
</DL>

<DL>
<DT>TtcChangeGraphics  (Document, View):</DT>

<DD>Display the form that allows user to change line weight, 
</DL>

<DL>
<DT>TtcChangePresentation  (Document, View):</DT>

<DD>Display the menu that allows user to change presentation schema of
document and its natures.
</DL>

<DL>
<DT>TtcChildElement  (Document, View):</DT>

<DD>Move the selection to the first enclosed element.
</DL>

<DL>
<DT>TtcCloseDocument  (Document, View):</DT>

<DD>Close the current document after acknowledgement if the document was
previously modified.
</DL>

<DL>
<DT>TtcCloseView  (Document, View):</DT>

<DD>Close the current view of the document and the document if it is the last
opened view. Close the document if that view is the last opened view.
</DL>

<DL>
<DT>TtcCopySelection  (Document, View):</DT>

<DD>Copy the current selection into the Thot clipboard.
</DL>

<DL>
<DT>TtcCopyToClipboard  (Document, View):</DT>

<DD>Copy the current selection into the X clipboard.
</DL>

<DL>
<DT>TtcCreateDocument  (Document, View):</DT>

<DD>Display the form that allows user to create a new document.
</DL>

<DL>
<DT>TtcCutSelection  (Document, View):</DT>

<DD>Delete the current selection and save it in the Thot clipboard.
</DL>

<DL>
<DT>TtcDeletePreviousChar  (Document, View):</DT>

<DD>Delete the previous character.
</DL>

<DL>
<DT>TtcDeleteSelection  (Document, View):</DT>

<DD>Delete the current selection.
</DL>

<DL>
<DT>TtcDisplayGraphicsKeyboard  (Document, View):</DT>

<DD>Display the graphic keyboard.
</DL>

<DL>
<DT>TtcDisplayGreekKeyboard  (Document, View):</DT>

<DD>Display the greek keyboard.
</DL>

<DL>
<DT>TtcDisplayLatinKeyboard  (Document, View):</DT>

<DD>Display the ISO Latin-1 keyboard.
</DL>

<DL>
<DT>TtcDisplayMathKeyboard  (Document, View):</DT>

<DD>Display the math-symbol keyboard.
</DL>

<DL>
<DT>TtcEndOfLine(Document, View):</DT>

<DD>Move the cursor to the end of the line.
</DL>

<DL>
<DT>TtcGotoPage  (Document, View):</DT>

<DD>Not implemented yet....
</DL>

<DL>
<DT>TtcHolophrast  (Document, View):</DT>

<DD>Not implemented yet....
</DL>

<DL>
<DT>TtcInclude (Document, View):</DT>

<DD>Obtain a  live  copy, i.e. a copy which is automatically updated each time
you modify the copied element. The <TT>TtcInclude</TT> command presents the
same menu as that offered by the <TT>TtcInsert</TT> command, i.e. the list of
elements that can be created before or after the selected part. Once you have
selected the type and the position of the copy, click with the left mouse
button on the element to be copied. You can click in any Thot window of a
document provided that you click on an element of the required type. You can
move throughout the document by using the scroll bars in order to display the
desired element before clicking on it.
</DL>

<DL>
<DT>TtcIndex (Document, View):</DT>

<DD>Activate the Thot index application. If the document does not already
include index marks, that function initializes the Thot index application and 
allows insertion of index marks in the insert menu. After that, the function
computes index marks to provide index table.
</DL>

<DL>
<DT>TtcInsert (Document, View):</DT>

<DD>Display the insert menu. This menu is built according to the current
selection and the document structure schema. Thus, it may vary. It displays
all element types that can be created before or after the current selection.
By selecting an item from this menu, you choose the element to be created and
its structural position.
</DL>

<DL>
<DT>TtcInsertPageBreak (Document, View):</DT>

<DD>Not implemented yet....
</DL>

<DL>
<DT>TtcNextChar (Document, View):</DT>

<DD>Move the cursor to the next character.
</DL>

<DL>
<DT>TtcNextElement (Document, View):</DT>

<DD>Move the selection to the next element.
</DL>

<DL>
<DT>TtcNextLine (Document, View):</DT>

<DD>Move the cursor one line down.
</DL>

<DL>
<DT>TtcOpenDocument (Document, View):</DT>

<DD>Display the form that allows user to open a new document.
</DL>

<DL>
<DT>TtcOpenView (Document, View):</DT>

<DD>Allow to open one of the available views of the document.
</DL>

<DL>
<DT>TtcPageDown (Document, View):</DT>

<DD>Move the current view one page down.
</DL>

<DL>
<DT>TtcPageEnd (Document, View):</DT>

<DD>Move the current view to the bottom of the document.
</DL>

<DL>
<DT>TtcPageTop (Document, View):</DT>

<DD>Move the current view to the top of the document.
</DL>

<DL>
<DT>TtcPageUp (Document, View):</DT>

<DD>Move the current view one page up.
</DL>

<DL>
<DT>TtcPaginateDocument (Document, View):</DT>

<DD>Not implemented yet....
</DL>

<DL>
<DT>TtcPaginateView (Document, View):</DT>

<DD>Not implemented yet....
</DL>

<DL>
<DT>TtcParentElement (Document, View):</DT>

<DD>Move the selection to the enclosing element.
</DL>

<DL>
<DT>TtcPaste (Document, View):</DT>

<DD>Insert the content of the Thot clipboard.
</DL>

<DL>
<DT>TtcPasteFromClipboard (Document, View):</DT>

<DD>Insert the content of the X clipboard.
</DL>

<DL>
<DT>TtcPreviousChar (Document, View):</DT>

<DD>Move the cursor to the previous
</DL>

<DL>
<DT>TtcPreviousElement (Document, View):</DT>

<DD>Move the selection to the previous element.
</DL>

<DL>
<DT>TtcPreviousLine (Document, View):</DT>

<DD>Move the cursor one line up.
</DL>

<DL>
<DT>TtcPrint (Document, View):</DT>

<DD>Start the printing process using options defined by the
<TT>TtcPrintSetup</TT> command.
</DL>

<DL>
<DT>TtcPrintSetup (Document, View):</DT>

<DD>Display the form that allows user to change printing options.
</DL>

<DL>
<DT>TtcSetupAndPrint (Document, View):</DT>

<DD>Display the form that allows user to change printing options. With option
to print.
</DL>

<DL>
<DT>TtcQuit (Document, View):</DT>

<DD>Close  all documents and quit the application.
</DL>

<DL>
<DT>TtcSaveDocument (Document, View):</DT>

<DD>Save the document at the same place.
</DL>

<DL>
<DT>TtcSaveDocumentAs (Document, View):</DT>

<DD>Display the save or export dialogue.
</DL>

<DL>
<DT>TtcSearchEmptyElement (Document, View):</DT>

<DD>Display the form that allows user to search empty elements in the current
document.
</DL>

<DL>
<DT>TtcSearchEmptyReference (Document, View):</DT>

<DD>Display the form that allows user to search empty references in the
current document.
</DL>

<DL>
<DT>TtcSearchReference (Document, View):</DT>

<DD>Display the form that allows user to search internal and external (located
in other documents) references to the current selected part of the document.
</DL>

<DL>
<DT>TtcSearchText (Document, View):</DT>

<DD>Display the form that allows user to search and replace text in the
current document.
</DL>

<DL>
<DT>TtcSetBackupInterval (Document, View):</DT>

<DD>Not implemented yet....
</DL>

<DL>
<DT>TtcSetDocumentPath (Document, View):</DT>

<DD>Not implemented yet....
</DL>

<DL>
<DT>TtcSetSchemaPath (Document, View):</DT>

<DD>Not implemented yet....
</DL>

<DL>
<DT>TtcSetVisibilityView (Document, View):</DT>

<DD>Allow user to filter what elements are displayed in the document view.
</DL>

<DL>
<DT>TtcSetZoomView (Document, View):</DT>

<DD>Allow user to grow or shrink character sizes in the document view.
</DL>

<DL>
<DT>TtcSpellCheck (Document, View):</DT>

<DD>Allow the user to check the spelling of a document being processed.
Checking is based on dictionaries. The checker compares the words of the text
with those in the available dictionaries. It suggests several replacements for
each word which has not been found in the dictionaries. The user can then
choose the correct word from the list of suggested words (or can type another
word). The replacement operation is performed by the checker.
</DL>

<DL>
<DT>TtcStartOfLine (Document, View):</DT>

<DD>Move the cursor to the beginning of the line.
</DL>

<DL>
<DT>TtcSwitchButtonBar (Document, View):</DT>

<DD>Alternatively, map an unmap the button bar in the document view.
</DL>

<DL>
<DT>TtcSwitchCommands (Document, View):</DT>

<DD>Alternatively, map and unmap the command zone (logo and textual commands)
in the document view.
</DL>

<P>The Thot standard commands <B>TtcInsertChar</B> and  <B>TtcInsertGraph</B>
need an extra parameter: the character to be inserted. These commands can be
called by application specific commands, but cannot appear in the menus
defined by the application schema EDITOR.A.</P>

<DL>
<DT>TtcInsertChar (Document, View, char):</DT>

<DD>This command inserts the character 'c' at the current insertion point.
</DL>

<DL>
<DT>TtcInsertGraph (Document, View, char):</DT>

<DD>This command inserts the graphics 'c' at the current insertion point.
</DL>

<H2><A NAME="secta4">4</A> Keyboard shortcuts</H2>

<P>It is convenient to be able to invoke menu commands from the keyboard. The
Thot toolkit provides a facility that let user accomplish this. When the
application starts, the Thot toolkit looks for the keyboard shortcuts file for
the application. This file defines a list of associations between a keyboard
sequence an the corresponding command.</P>

<P>The syntax used to define association is:</P>
<PRE>
Directive = KeySeq ':' IdentCommand ;
KeysSeq = KeySet [ ',' KeySet ] ;
KeySet = [ Modifier ] [ 'Shift' ] Key ;
Key = '&lt;Key&gt;' KeyValue / '&lt;Key&gt;' SpecialKey ;
Modifier = 'Ctrl' / 'Alt' / 'Meta' ;
KeyValue = 'a' / 'b' / ... ;
SpecialKey = 'Escape' / 'Delete' / 'Space' / 'BackSpace' / 'Return' / 'Up' /
'Down' / 'Left' / 'Right' / 'Home' / 'End' / 'F1' / ... / 'L1' / ... / 'R1' /
... ;
IdentCommand = 'TtcInsertChar(' Char ')' / NAME '()' ;
Char = KeyValue / OctalValue ; 
OctalValue = '\' NUMBER ; 
</PRE>

<P>An <TT>IdentCommand</TT> can be either a standard Thot command or an
application specific command. We give below the example of the
<TT>amaya.keyboard</TT> file.</P>
<PRE>
#Amaya example
Ctrl &lt;Key&gt;1: CreateHeading1()
Ctrl &lt;Key&gt;2: CreateHeading2()
Ctrl &lt;Key&gt;3: CreateHeading3()
Ctrl &lt;Key&gt;Space: TtcInsertChar("\240")
Ctrl &lt;Key&gt;Return: TtcInsertChar("\212")
Ctrl &lt;Key&gt;x , Ctrl &lt;Key&gt;s: SaveDocument()
Ctrl &lt;Key&gt;x , Ctrl &lt;Key&gt;p: TtcPrint()
Ctrl &lt;Key&gt;x , Ctrl &lt;Key&gt;c: TtcCloseDocument()
Ctrl &lt;Key&gt;x , Ctrl &lt;Key&gt;f: TtcSearchText()
Ctrl &lt;Key&gt;c: TtcCopySelection()
Ctrl &lt;Key&gt;y: TtcPaste()
Ctrl &lt;Key&gt;w: TtcCutSelection()
Ctrl &lt;Key&gt;d: TtcDeleteSelection()
&lt;Key&gt;Delete: TtcDeleteSelection()
&lt;Key&gt;Escape: TtcParentElement()
Ctrl &lt;Key&gt;-: TtcChildElement()
Ctrl &lt;Key&gt;a: TtcStartOfLine()
Ctrl &lt;Key&gt;e: TtcEndOfLine()
&lt;Key&gt;Return: TtcCreateElement()
&lt;Key&gt;Home: TtcStartOfLine()
&lt;Key&gt;End: TtcEndOfLine()
Ctrl &lt;Key&gt;b: TtcPreviousElement()
Ctrl &lt;Key&gt;f: TtcNextElement()
&lt;Key&gt;L6: TtcCopyToClipboard()
&lt;Key&gt;L8: TtcPasteFromClipboard()
</PRE>

<P>The keyboard shortcuts file can be located either in the user's
<TT>HOME</TT> directory or in the <TT>bin</TT> directory within the Thot
hierarchy.</P>

<P>File paths are:</P>

<UL>
<LI>$HOME/'name'.keyboard
<LI>$THOTDIR/bin/'name'.keyboard
</UL>

<P>  where 'name' represents the application name.</P>

<H2><A NAME="secta5">5</A> <A NAME="L500">Events</A></H2>

<P>Events can take two different forms: <EM>.Pre</EM> or <EM>.Post</EM>. The
actions called by the <EM>.Pre</EM> events must return a boolean value which
is <EM>True</EM> if the action replaces the standard processing of the editor.
The actions called by the <EM>.Post</EM> events have no return value. The
<EM>.Pre</EM> and <EM>.Post</EM> forms of the same event generally call the
corresponding actions with different parameters.</P>

<P>Events are grouped in several categories depending on the objects to which
they are transmitted: attributes, elements, specific presentation rules,
documents, views, application.</P>

<H3><A NAME="sectb51">5.1</A> <A NAME="L525">Events for attributes</A></H3>

<P>The following events only appear in the <TT>DEFAULT</TT> section or in the
<TT>ATTRIBUTES</TT> section of an application schema.</P>

<P>If they appear in the <TT>DEFAULT</TT> section, they are raised each time
an attribute of any type is created, modified, deleted, saved or read
(according to the event), whatever the element in question.</P>

<P>In the <TT>ATTRIBUTES</TT> section, these events are associated with an
attribute type and raised by the editor when attributes of this type are
created, deleted, modified, saved or read (according to the event), whatever
the element in question.</P>

<P>Each attribute's event is accompanied with a pointer to the subsequent
structure (this structure is defined in the <EM>appaction.h</EM> file):</P>
<PRE>
typedef struct {
  TTEevent event;
  Document document;
  Element element;
  Attribute attribute;
  AttributeType attributeType;
} NotifyAttribute;
 
</PRE>

<DL>
<DT>AttrMenu.Pre (NotifyElement):</DT>

<DD>The editor is composing the ``Attributes'' menu and will add to this menu
an item which allows the user to create an attribute of type
<TT>attributeType</TT> for element <TT>element</TT>. The <EM>attribute</EM>
field is not filled since the attribute has not yet been created.
<P>If the action called by the event returns <EM>True</EM>, the corresponding
item is not included in the menu; if it returns <EM>False</EM>, the item is
normally included in the menu.
There is no <TT>AttrMenu.Post</TT> event.</P>

</DL>

<DL>
<DT>AttrCreate.Pre (NotifyAttribute):</DT>

<DD>The editor is going to create for the element <TT>element</TT> indicated
an attribute of type <TT>attributeType</TT>. The <EM>attribute</EM> field is
not filled since the attribute has not yet been created.
If it deals with a mandatory attribute (preceded by an exclamation mark in the
structure schema), the attribute is always created by the editor, whether the
action returns <EM>True</EM> or <EM>False</EM> and the editor raises the
events <TT>AttrCreate.Pre</TT> (before creating the attribute) and
<TT>AttrModify.Pre</TT> (before requiring the user to assign a value to the
attribute).
Attributes with an imposed value (entered with the <TT>WITH</TT> keyword in
the structure schema), do not raise <TT>AttrCreate.Pre</TT> event when
created.
</DL>

<DL>
<DT>AttrCreate.Post (NotifyAttribute):</DT>

<DD>The editor has created the attribute of type <TT>attributeType</TT> for
the element <TT>element</TT>.
Attributes with imposed value (entered with the <TT>WITH</TT> keyword in the
structure schema) do not raise a <TT>AttrCreate.Post</TT> event.
</DL>

<DL>
<DT>AttrModify.Pre (NotifyAttribute):</DT>

<DD>The editor is going to change the value of the indicated attribute
<TT>attribute</TT> for the element <TT>element</TT>.
If this is a mandatory attribute (i.e. an attribute preceded by an exclamation
mark in the structure schema) and if the action gives a value to the attribute
and returns <EM>True</EM>, the editor will not require the user to give a
value.
</DL>

<DL>
<DT>AttrModify.Post (NotifyAttribute):</DT>

<DD>The editor has changed the value of the attribute <TT>attribute</TT> for
the element <TT>element</TT>. The attribute then has the new value.
</DL>

<DL>
<DT>AttrDelete.Pre (NotifyAttribute):</DT>

<DD>The editor is going to delete the attribute <TT>attribute</TT> for the
element in question. The attribute is still attached to the element and its
value is still accessible.
</DL>

<DL>
<DT>AttrDelete.Post (NotifyAttribute):</DT>

<DD>The editor has removed an attribute of type <TT>attributeType</TT> for the
indicated element. The attribute field is not filled since the attribute no
longer exists.
</DL>

<DL>
<DT>AttrRead.Pre (NotifyAttribute):</DT>

<DD>This event occurs when a document file is read and even if this is
required by the API (exception to the rule). The editor starts reading an
attribute of type <TT>attributeType</TT>. The attribute field is not
significant. If the action returns <EM>True</EM>, the attribute is not
included in the abstract tree.
</DL>

<DL>
<DT>AttrRead.Post (NotifyAttribute):</DT>

<DD>The editor has read the attribute attribute of the element element and has
inserted it into the abstract tree.
</DL>

<DL>
<DT>AttrSave.Pre (NotifyAttribute):</DT>

<DD>This event occurs when a document is saved to a file and even if the
backup is required by the API (exception to the rule). The editor writes the
attribute<TT> attribute</TT> of the element <TT>element</TT>. If the action
returns <EM>True</EM>, the attribute is not written in the file.
</DL>

<DL>
<DT>AttrSave.Post (NotifyAttribute):</DT>

<DD>The editor has written in the file the attribute <TT>attribute</TT> of the
element <TT>element</TT>.
</DL>

<DL>
<DT>AttrExport.Pre (NotifyAttribute):</DT>

<DD>This event occurs when a document is exported in a format that is not the
standard Thot format (pivot format), and even if export is required by an
application through the API (exception to the rule). The editor is going to
generate the translation of the attribute<TT> attribute</TT> of the element
<TT>element</TT>. If the action returns <EM>True</EM>, the attribute is not
exported in the output file.
</DL>

<DL>
<DT>AttrExport.Post (NotifyAttribute):</DT>

<DD>The editor has exported in the output file the attribute
<TT>attribute</TT> of the element <TT>element</TT>.
</DL>

<H3><A NAME="sectb52">5.2</A> Events for elements</H3>

<P>The following events only appear in the DEFAULT or ELEMENTS section of an
application schema.</P>

<P>In the DEFAULT section, they are raised as soon as any element is affected
by the relevant event.</P>

<P>In the <TT>ELEMENTS</TT> section, they are associated with an element type
and raised as soon as an element of this type is affected by the relevant
event.</P>

<P>Three different structures can accompany the events on elements (see the
structure specified for each event. These structures are defined in the
<TT>appaction.h</TT> file):</P>
<PRE>
typedef struct {
  TTEevent event;
  Document document;
  Element element;
  ElementType elementType;
  int position;
} NotifyElement;
 
typedef struct {
  TTEevent event;
  Document document;
  Element element;
  ElementType elementType;
  ElementType targetElementType;
} NotifyOnElementType;
 
typedef struct {
  TTEevent event;
  Document document;
  Element element;
  Element target;
  Document targetdocument;
} NotifyOnTarget;
 
typedef struct {
  TTEevent event;
  Document document;
  Element element;
  Element target;
  int value;
} NotifyOnValue;
 
</PRE>

<DL>
<DT>ElemMenu.Pre (NotifyElement):</DT>

<DD>The editor is composing the ``Insert'' or the ``Paste'' menu and will add
to this menu an item which allows the user to create or paste an element of
type <TT>elementType</TT> (with its descent) as the child of the element
<TT>element</TT>. The <TT>position</TT> field gives the position of the
element that will be created or pasted (when the user chooses the item of the
menu) in the list of the children of <TT>element</TT> (0 before the first
child or as the first child if element has no child, 1 after the first child,
2 after the second one, etc.).
If the event is in the <TT>ELEMENTS</TT> section, it is only raised when the
editor includes in the menu the item regarding an element of the corresponding
type.
If the event is in the <TT>DEFAULT</TT> section, it is raised as soon as the
editor includes an item in the ``Insert'' menu, whatever the element type in
question.
If the action called by the event returns <EM>True</EM>, the corresponding
item is not included in the menu; if it returns <EM>False</EM>, the item is
normally included in the menu.
There is no <TT>ElemMenu.Post event</TT>.
</DL>

<DL>
<DT>ElemTransform.Pre (NotifyOnElementType):</DT>

<DD>The editor is changing the type of selected elements. The event is raised
if the editor could not transform the whole selection into
<TT>targetElementType</TT>, and before it tries to change individually each
selected element.
<P>If the event is in the <TT>ELEMENTS</TT> section, it is raised only if all
the selected elements belong to the corresponding type.</P>

<P>If the event is in the section <TT>DEFAULT</TT>, it is sent whatever the
type of selected elements is.</P>

<P>If the action called by the event returns <I>True</I>, the editor will not
try to change individually the type of selected elements, if it returns
<I>False</I>, the editor will try.</P>

<P>There is no ElemTransorm.Post event.</P>

</DL>

<DL>
<DT>ElemNew.Pre (NotifyElement):</DT>

<DD>The user is going to create a new element of type <TT>elementType</TT>
(with its descent) as the child of the element <TT>element</TT>. The
<TT>position</TT> field gives the position of the element which will be
created in the list of the children of <TT>element</TT> (0 before the first
child or as the first child if the element has no child, 1 after the first
child, 2 after the second one, etc.).
If the event is in the <TT>ELEMENTS</TT> section, it is raised only when the
user wants to create an element of the corresponding type.
If the event is in the <TT>DEFAULT</TT> section, it is raised as soon as the
user creates a new element, whatever its type.
In all cases, this event is only raised for the root of a subtree that will be
created and not for each element of this subtree.
</DL>

<DL>
<DT>ElemNew.Pre (NotifyElement):</DT>

<DD>The user is going to create a new element of type <TT>elementType</TT>
(with its descent) as the child of the element <TT>element</TT>. The
<TT>position</TT> field gives the position of the element which will be
created in the list of the children of <TT>element</TT> (0 before the first
child or as the first child if the element has no child, 1 after the first
child, 2 after the second one, etc.).
If the event is in the <TT>ELEMENTS</TT> section, it is raised only when the
user wants to create an element of the corresponding type.
If the event is in the <TT>DEFAULT</TT> section, it is raised as soon as the
user creates a new element, whatever its type.
In all cases, this event is only raised for the root of a subtree that will be
created and not for each element of this subtree.
</DL>

<DL>
<DT>ElemNew.Post (NotifyElement):</DT>

<DD>The element <TT>element</TT> has just been created and placed into the
abstract tree of its document. The <TT>position</TT> field has no meaning.
If the event is in the <TT>ELEMENTS</TT> section, it is only raised when the
user has created an element of the corresponding type.
If the event is in the <TT>DEFAULT</TT> section, it is raised each time the
user creates a new element, whatever its type.
When the event has created a subtree, this event can only be raised for the
root of the subtree newly created or on the contrary to each element of this
subtree, depending on the notification mode in which the document can be found
(see the <TT>TtaSetNotificationMode</TT> of the API). However, even when the
document is included in the full notification mode, the event is only raised
for the elements which require it.
</DL>

<DL>
<DT>ElemRead.Pre (NotifyElement):</DT>

<DD>This event occurs when a document file is read and even if this is
required by the API (exception to the rule). The editor starts reading an
element of type <TT>elementType</TT> which must be the last child of
<TT>element</TT>. The <TT>position</TT> field has no meaning. If the action
returns <EM>True</EM>, the element (and the whole subtree) is not included in
the abstract tree.
</DL>

<DL>
<DT>ElemRead.Post (NotifyElement):</DT>

<DD>The editor has read the element <TT>element</TT> and the whole subtree and
has inserted it into the abstract tree. The <TT>position</TT> field has no
meaning.
</DL>

<DL>
<DT>ElemSave.Pre (NotifyElement):</DT>

<DD>This event occurs when a document is saved to a file and even if the
backup is required by the API (exception to the rule). The editor is going to
write the element <TT>element</TT>. The <TT>position</TT> field has no
meaning. If the action returns <EM>True</EM>, the subtree is not written in
the file.
</DL>

<DL>
<DT>ElemSave.Post (NotifyElement):</DT>

<DD>The editor has written the element <TT>element</TT>. The <TT>position</TT>
field has no meaning.
</DL>

<DL>
<DT>ElemExport.Pre (NotifyElement):</DT>

<DD>This event occurs when a document is exported, and even if export is
required by the API (exception to the rule). The editor is going to generate
the translation of the element <TT>element</TT>. The <TT>position</TT> field
has no meaning. If the action returns <EM>True</EM>, the subtree is not
exported in the output file.
</DL>

<DL>
<DT>ElemExport.Post (NotifyElement):</DT>

<DD>The editor has exported the element <TT>element</TT>. The
<TT>position</TT> field has no meaning.
</DL>

<DL>
<DT>ElemDelete.Pre (NotifyElement):</DT>

<DD>The element <TT>element</TT> will be removed from its abstract tree if a 
&laquo; Delete &raquo; or &laquo; Cut &raquo; command is issued by the user,
or if the Thot kernel has detected two Text elements that may be merged. This
element is still included in the abstract tree when the event is raised.
<P>The <TT>position</TT> field may take different values depending on the
three following cases:</P>

<DL>
<DT>Case 1: &laquo; Delete &raquo; or &laquo; Cut &raquo;</DT>

<DD>This event signals the deletion of an item of a delete sequence that
depends on the selection. This functionnality allows the application, if such
treatment is requested, to postpone its treatment until the full delete
sequence is obtained.
<P>Values of the position field maty be the following:</P>

<P>TTE_STANDARD_DELETE_FIRST_ITEMS: the element is among the first items of
the delete sequence: the event delete sequence is not complete, and next
event(s) will follow this one.</P>

<P>TTE_STANDARD_DELETE_LAST_ITEM: this is the last item of the delete
sequence.</P>

</DL>

<DL>
<DT>Case 2: Two Text units may be merged</DT>

<DD>Two Text elements own the same caracteristics, and may be merged. The
content of the second element will be merged into the first one, and this
element will be deleted from the abstract tree if the application authorizes
this deletion. Otherwise, these two elements will come apart.
<P>The position field value is: TTE_MERGE_DELETE_ITEM</P>

</DL>

<DL>
<DT>Case 3: Requested deleting (must be suppressed)</DT>

<DD>The element will be necessarily deleted independent of the value returned
by the event treatment. This event goal is simply indicative.
<P>Value of the position field is: TTE_TOOLKIT_DELETE</P>

</DL>

<P>When the event must remove a whole subtree, this event can only be raised
for the root of the subtree to be removed or on the contrary, to each element
of this subtree, depending on which notification mode the document is in (see
the <TT>TtaSetNotificationMode</TT> function of the API). However, even when
the document is in the full notification mode, the event is only raised for
the elements which require it.</P>

</DL>

<DL>
<DT>ElemDelete.Post (NotifyElement):</DT>

<DD>An element of type <TT>elementType</TT>, child of element, has been
removed from the abstract tree. The <TT>position</TT> field gives the position
of the removed element in the list of the children of <TT>element</TT> (0 for
the first child, 1 for the second, etc.). If a subtree has been deleted, the
event is only raised for the root of this subtree and not to each element of
the subtree, even if the document is included in the full notification mode.
</DL>

<DL>
<DT>ElemSelect.Pre (NotifyElement):</DT>

<DD>The user wants to select the element <TT>element</TT>. The selection has
not been already made. This event is also raised before a double-click and
when the editor follows a hypertext link. The <TT>position</TT> field has no
meaning.
</DL>

<DL>
<DT>ElemSelect.Post (NotifyElement):</DT>

<DD>The element <TT>element</TT> has just been selected by the user. The
<TT>position</TT> field has no meaning.
</DL>

<DL>
<DT>ElemExtendSelect.Pre (NotifyElement):</DT>

<DD>The user wants to extend the selection to the element <TT>element</TT>.
This event is only raised when the selection implies at least two elements.
The <TT>position</TT> field has no meaning.
</DL>

<DL>
<DT>ElemExtend.Post (NotifyElement):</DT>

<DD>The selection has just been extended to the element <TT>element</TT>. The
<TT>position</TT> field has no meaning.
</DL>

<DL>
<DT>ElemActivate.Pre (NotifyElement):</DT>

<DD>The user has just double-clicked on the element <TT>element</TT>. The
selection has not already changed. This event is accepted for all elements
(references or not). The <TT>position</TT> field has no meaning.
</DL>

<DL>
<DT>ElemActivate.Post (NotifyElement):</DT>

<DD>The selection has been moved once the user has double-clicked on the
element <TT>element</TT>. You can ask the API where the new selection is if is
the <TT>ElemSelect</TT> event has not been retrieved. The <TT>position</TT>
field has no meaning.
</DL>

<DL>
<DT>ElemSetReference.Pre (NotifyOnTarget):</DT>

<DD>The user requires that the reference element <TT>element</TT> points to
the element <TT>target</TT> belonging to the <TT>targetdocument</TT> document.
The link is not already established and the reference element still points its
old target (or nothing at all). In the <TT>ELEMENTS</TT> section, this event
is only valid for the elements of type reference (this is checked by the
compiler). If this event is included in the <TT>DEFAULT</TT> section, it will
only apply to the reference elements. This event is not accepted in the
<TT>ATTRIBUTES</TT> section even for reference attributes (see the
<TT>AttrModify</TT> event).
</DL>

<DL>
<DT>ElemSetReference.Post (NotifyOnTarget):</DT>

<DD>The reference element <TT>element</TT> has just changed its target upon
the user's request. It now points to the element <TT>target</TT> belonging to
the <TT>targetdocument</TT> document.
</DL>

<DL>
<DT>ElemInclude.Pre (NotifyElement):</DT>

<DD>The user is going to include a new element of type <TT>elementType</TT> as
the child of the element <TT>element</TT>. The <TT>position</TT> field gives
the position of the element which will be included in the list of the children
of <TT>element</TT> (0 before the first child, 1 after the first child, 2
after the second one, etc.).
If a whole subtree is to be included, the event is only raised for the root of
the subtree.
</DL>

<DL>
<DT>ElemInclude.Post (NotifyElement):</DT>

<DD>The element <TT>element</TT> has just been included. The <TT>position</TT>
field has no meaning.
If a whole subtree has been included, the event is only raised for the root of
this subtree.

</DL>

<DL>
<DT>ElemCopy.Pre (NotifyElement):</DT>

<DD>The user is going to copy the element <TT>element </TT>contained in the
abstract tree. The <TT>position</TT> field has no meaning.
When the event must copy a whole subtree, this event can only be raised for
the root of the subtree to be copied or to each element of the subtree,
depending on the notification mode in which the document is placed (see the
<TT>TtaSetNotificationMode</TT> function of the API). However, even when the
document is in the full notification mode, the event is only raised for the
elements which require it. 
</DL>

<DL>
<DT>ElemCopy.Post (NotifyElement):</DT>

<DD>The element <TT>element</TT> has just been copied. It is placed in the
abstract tree. The <TT>position</TT> field has no meaning.
When the event has copied a subtree, this event can only be raised for the
root of the copied subtree or on the contrary to each element of the subtree,
depending on the notification mode of the document (see the
<TT>TtaSetNotificationMode</TT> function of the API). However, even when the
document is in the full notification mode, the event is only raised for the
elements which have required it.
</DL>

<DL>
<DT>ElemPaste.Pre (NotifyOnValue):</DT>

<DD>The user is going to paste the element <TT>target</TT> as the descendant
of the element <TT>element</TT>. The element <TT>target</TT> is not already
pasted at the position required by the user. The <TT>value</TT> field gives
the position of the element to be pasted in the list of the children of
<TT>element</TT> (0 before the first child, 1 after the first child, 2 after
the second child, etc.).
In all cases, this event is only raised for the root of a subtree which will
be pasted and not to each element of the subtree.
</DL>

<DL>
<DT>ElemPaste.Post (NotifyElement):</DT>

<DD>The element <TT>element</TT> has just been pasted. It is placed into the
abstract tree. The <TT>position</TT> field contains the document from which
the element has been copied or cut.
When the event has pasted a subtree, this event can only be raised for the
root of the pasted subtree or on the contrary to each element of the subtree,
depending on the notification mode of the document (see the
<TT>TtaSetNotificationMode</TT> function of the API). However, even when the
document is in the full notification mode, the event is only raised for the
elements which have required it.
</DL>

<DL>
<DT>ElemChange.Pre (NotifyElement):</DT>

<DD>The user is going to change the type of element <TT>element</TT>. The
element has still its old type. The <TT>elementType</TT> field indicates the
new type that will be given to the element.  The <TT>position</TT> field has
no meaning.
</DL>

<DL>
<DT>ElemChange.Post (NotifyElement):</DT>

<DD>The element <TT>element</TT> has just changed type. The
<TT>elementType</TT> field indicates the previous type of the element. The
<TT>position</TT> field has no meaning.
</DL>

<DL>
<DT>ElemMove.Pre (NotifyElement):</DT>

<DD>The user is going to create a surrounding element for element
<TT>element</TT>. The <TT>position</TT> field has no meaning.
</DL>

<DL>
<DT>ElemMove.Post (NotifyElement):</DT>

<DD>The element <TT>element</TT> has just been surrounded by a new element.
The <TT>position</TT> field has no meaning.
</DL>

<DL>
<DT>ElemTextModify.Pre (NotifyOnTarget):</DT>

<DD>The user starts modifying the contents of the text or image leaf
(modification of the name of the image file) <TT>target</TT> in the element
<TT>element</TT>. The <TT>element</TT> parameter is the element of the type
which has requested the event and which is an ascendant of the <TT>target</TT>
leaf. The text leaf still has its previous contents.
If this event is in the <TT>ELEMENTS</TT> section, it is only raised if one of
the ascendants (at any level) of the text leaf in question has the type with
which the event is associated. If several ascendants require the event, it is
raised for each one and first to the ones at the lowest level.
If this event is in the <TT>DEFAULT</TT> section, it is raised as soon as any
text leaf is affected. In this case, both parameters <TT>element </TT>and
<TT>target</TT> have the same value: the affected text leaf.
The return of the function called in the application is indifferent: whether
it returns True or False, the behaviour of the editor is not modified.
</DL>

<DL>
<DT>ElemTextModify.Post (NotifyOnTarget):</DT>

<DD>The user has finished modifying the contents of the text or image leaf
(modification of the name of the image file) <TT>target</TT> of the element
<TT>element</TT>. Several changes can have been made since the corresponding
<TT>ElemTextModify.Pre</TT> event has been raised: inserted, pasted, deleted
characters, etc. When the event is raised, the text leaf has its new contents.
This event is raised in the same way as the <TT>ElemTextModify.Pre</TT> event.
</DL>

<DL>
<DT>ElemGraphModify.Pre (NotifyOnValue):</DT>

<DD>The user wants to replace by <TT>value</TT> the contents of the graphic or
symbol leaf <TT>target</TT> which has an ascendant <TT>element</TT>.
<TT>Element</TT> is the element of the type with which the event is
associated. If the event is defined in the <TT>DEFAULT</TT> section then
<TT>element</TT> is equal to <TT>target</TT>.
</DL>

<DL>
<DT>ElemGraphModify.Post (NotifyOnValue):</DT>

<DD>The user has just replaced the contents of the graphic or symbol leaf
<TT>target</TT> which has an ascendant <TT>element</TT>.
</DL>

<H3><A NAME="sectb53">5.3</A> Events for the specific presentation</H3>

<P>The following events can only appear in the <TT>DEFAULT</TT> or
<TT>ELEMENTS</TT> section of an application schema.</P>

<P>In the <TT>DEFAULT</TT> section, they are raised each time a specific
presentation rule is created, modified or deleted (depending on the event),
whatever the element in question.</P>

<P>In the <TT>ELEMENTS</TT> section, they are associated with an element type
and raised by the editor when the specific rule concerns an element of the
type in question.</P>

<P>A single type of context is associated with the events for the specific
presentation (this structure is defined in the <TT>appaction.h</TT> file):</P>
<PRE>
typedef struct {
  TTEevent event;
  Document document;
  Element element;
  PRule pRule;
  int pRuleType;
} NotifyPresentation;
 
</PRE>

<DL>
<DT>PRuleCreate.Pre (NotifyPresentation):</DT>

<DD>The user requires a specific presentation rule of type <TT>typePRule</TT>
to be added for the element <TT>element</TT>. The rule is not already added.
The <TT>pRule</TT> field has no significant value.
</DL>

<DL>
<DT>PRuleCreate.Post (NotifyPresentation):</DT>

<DD>The <TT>pRule</TT> rule has just been added to the element
<TT>element</TT>.
</DL>

<DL>
<DT>PRuleModify.Pre (NotifyPresentation):</DT>

<DD>The user wants to change the value of the <TT>pRule</TT> specific
presentation rule associated with the element <TT>element</TT>.
</DL>

<DL>
<DT>PRuleModify.Post (NotifyPresentation):</DT>

<DD>The user has just changed the value of the <TT>pRule</TT> specific
presentation rule associated with the element <TT>element</TT>.
</DL>

<DL>
<DT>PRuleDelete.Pre (NotifyPresentation):</DT>

<DD>The user wants to remove a <TT>pRule</TT> specific presentation rule
associated with the element <TT>element</TT>.
</DL>

<DL>
<DT>PRuleDelete.Post (NotifyPresentation):</DT>

<DD>The user has removed a specific presentation rule of type
<TT>pRuleType</TT> associated with the element <TT>element</TT>. The
<TT>pRule</TT> field has no significant value.
</DL>

<H3><A NAME="sectb54">5.4</A> Events for documents</H3>

<P>The following events are intended for documents. They can only appear in
the <TT>DEFAULT</TT> section of an application schema. If it is an application
schema associated with a type of document, they are raised each time a
document of this type is (respectively) opened, created, closed or saved. If
they are included in the <TT>DEFAULT</TT> section of the <TT>EDITOR.A</TT>
schema, these events are raised whatever the type of document.</P>

<P>Only one type of context accompanies the events for documents. The
<TT>view</TT> field is not significant for any event on documents (this
structure is defined in the <TT>appaction.h</TT> file):</P>
<PRE>
typedef struct {
  TTEevent event;
  Document document;
  View view;
} NotifyDialog;
</PRE>

<DL>
<DT>DocOpen.Pre (NotifyDialog):</DT>

<DD>The user requires a document to be opened. The document is not already
opened but the <TT>document</TT> field already contains the identifier to be
associated with the document if the application accepts to open it.
</DL>

<DL>
<DT>DocOpen.Post (NotifyDialog):</DT>

<DD>The user has opened the document designated by the <TT>document</TT>
field.
</DL>

<DL>
<DT>DocCreate.Pre (NotifyDialog):</DT>

<DD>The user requires a new document to be created. The document is not
already created but the <TT>document</TT> field already contains the
identifier to be associated with the document if the application accepts its
creation.
</DL>

<DL>
<DT>DocCreate.Post (NotifyDialog):</DT>

<DD>The user has created the document designated by the <TT>document</TT>
field.
</DL>

<DL>
<DT>DocClose.Pre (NotifyDialog):</DT>

<DD>The user requires the document designated by the <TT>document</TT> field
to be closed. The document is still open.
</DL>

<DL>
<DT>DocClose.Post (NotifyDialog):</DT>

<DD>The user has closed the document designated by the <TT>document</TT>
field. This document identifier is no longer used.
</DL>

<DL>
<DT>DocSave.Pre (NotifyDialog):</DT>

<DD>The user requires the document designated by the <TT>document</TT> field
to be saved. The document is not saved yet.
</DL>

<DL>
<DT>DocSave.Post (NotifyDialog):</DT>

<DD>The user has saved the document designated by the <TT>document</TT> field.
</DL>

<DL>
<DT>DocExport.Pre (NotifyDialog):</DT>

<DD>The user requires the document designated by the <TT>document</TT> field
to be exported. The document is not exported yet.
</DL>

<DL>
<DT>DocExport.Post (NotifyDialog):</DT>

<DD>The user has exported the document designated by the <TT>document</TT>
field.
</DL>

<H3><A NAME="sectb55">5.5</A> Events for views</H3>

<P>The following events are intended for views. They can only appear in the
<TT>DEFAULT</TT> section of an application schema and concern all views of a
given document (if they are in an application schema associated with this type
of document) or all views of all types of documents (if they are in the
<TT>EDITOR.A</TT> schema).</P>

<P>Two types of context can accompany the events for views (these structures
are defined in the <TT>appaction.h</TT> file):</P>
<PRE>
typedef struct {
  TTEevent event;
  Document document;
  View view;
} NotifyDialog;
 
typedef struct {
  TTEevent event;
  Document document;
  int verticalValue;
  int horizontalValue;
} NotifyWindow;
</PRE>

<DL>
<DT>ViewOpen.Pre (NotifyDialog):</DT>

<DD>The editor is going to open a view for the document designated by the
<TT>document</TT> field. The <TT>view</TT> field is the view which will open.
</DL>

<DL>
<DT>ViewOpen.Post (NotifyDialog):</DT>

<DD>The editor has just opened the view for the document <TT>document</TT>.
The  view  field is the view which is opened.
</DL>

<DL>
<DT>ViewClose.Pre (NotifyDialog):</DT>

<DD>The editor is going to close the view <TT>view</TT> for the document
<TT>document</TT>.
</DL>

<DL>
<DT>ViewClose.Post (NotifyDialog):</DT>

<DD>The editor has just closed the view <TT>view</TT> for the document
<TT>document</TT>.
</DL>

<DL>
<DT>ViewResize.Pre (NotifyWindow):</DT>

<DD>The editor is going to resize the view <TT>view</TT> for the document
<TT>document</TT>. The parameters <TT>verticalValue</TT> and
<TT>horizontalValue</TT> give the vertical and horizontal variations of the
window. These values are expressed in pixels and can be positive or negative
numbers. A negative value expresses a shrinking of the window.
</DL>

<DL>
<DT>ViewResize.Post (NotifyWindow):</DT>

<DD>The editor has just resized the view <TT>view</TT> for the document
<TT>document</TT>.. The parameters <TT>verticalValue</TT> and
<TT>horizontalValue</TT> give the vertical and horizontal variations of the
window. These values are expressed in pixels and can be positive or negative
numbers. A negative value expresses a shrinking of the window.
</DL>

<DL>
<DT>ViewScroll.Pre (NotifyWindow):</DT>

<DD>The editor is going to scroll the view <TT>view</TT> for the document
<TT>document</TT>. The parameters <TT>verticalValue</TT> and
<TT>horizontalValue</TT> give the vertical or horizontal scrolling value (one
of them is nul). The scrolling value is expressed in pixels and can be a
positive or negative number. When the scroll is done by a jump to a specific
point within the document, the editor cannot compute the scrolling value; the
value 65535 is returned in that case.
</DL>

<DL>
<DT>ViewScroll.Post (NotifyWindow):</DT>

<DD>The editor has just scrolled the view <TT>view</TT> for the document
<TT>document</TT>. The parameters <TT>verticalValue</TT> and
<TT>horizontalValue</TT> give the vertical or horizontal scrolling value (one
of them is nul). The scrolling value is expressed in pixels and can be a
positive or negative number. When the scroll is done by a jump to a specific
point within the document, the editor cannot compute the scrolling value; the
value 65535 is returned in that case.
</DL>

<H3><A NAME="sectb56">5.6</A> Events for the application</H3>

<P>The events described in this section do not concern a particular object but
the whole application. They appear when the editor is launched and closed.</P>

<P>As they are not intended for a particular type of document, these events
can only appear in the <TT>EDITOR.A</TT> schema. They are independent of any
element or attribute. As a result, they can only appear in the
<TT>DEFAULT</TT> section of this schema.</P>

<P>Each event for the application is accompanied with a pointer to the
subsequent structure (this structure is defined in the <TT>appaction.h</TT>
file):</P>
<PRE>
typedef struct {
  TTEevent event;
} NotifyEvent;
</PRE>

<DL>
<DT>Init.Pre (NotifyEvent):</DT>

<DD>The editor is going to start. This event (and the next one) allows the
application to carry out initializations. If the action triggered off by the
event returns <TT>True</TT>, the editor does not start and the application
immediately ends.
</DL>

<DL>
<DT>Init.Post (NotifyEvent):</DT>

<DD>The editor has just started. It can now receive the events issued by the
user and the calls made by the application through the API.
</DL>

<DL>
<DT>Exit.Pre (NotifyEvent):</DT>

<DD>The editor is going to stop once the ``Quit'' command has been issued by
the user. No operation has been already performed. In particular, all opened
documents and views are still opened. If the action triggered off by this
event returns <TT>True</TT>, the editor does not do anything and the editing
session carries on.
</DL>

<DL>
<DT>Exit.Post (NotifyEvent):</DT>

<DD>The editor stops. The application can still use the API but all the
documents which were opened at the end of the session are already closed.
</DL>

<H2><A NAME="secta6">6</A> Defining actions</H2>

<P>The actions of the application always receive a parameter which is a
pointer to a context whose structure depends on the processed event. If the
action knows the processed event, it can directly handle the parameter with
the correct structure (NotifyEvent, NotifyDialog, etc.). Conversely, if the
action is able to process several events, it can use the subsequent
declaration in order to sign the parameter and test the value of the event
field in order to analyze the rest of the context (these definitions can be
found in the <TT>appaction.h</TT> file):</P>
<PRE>
typedef union {
  NotifyEvent notifyevent;
  NotifyDialog notifydialog;
  NotifyWindow notifywindow;
  NotifyAttribute notifyattribute;
  NotifyElement notifyelement;
  NotifyOnElementType notifyonelementtype;
  NotifyOnTarget notifyontarget;
  NotifyOnValue notifyonvalue;
  NotifyPresentation notifypresentation;
} Notify;
 
</PRE>

<P>The list of events is defined as follows (only internal events are
listed):</P>
<PRE>
typedef enum {
  TteAttrMenu,
  TteAttrCreate,
  TteAttrModify,
  TteAttrRead,
  TteAttrSave,
  TteAttrExport,
  TteAttrDelete,
 
  TteElemMenu,
  TteElemTransform,
  TteElemNew,
  TteElemRead,
  TteElemSave,
  TteElemExport,
  TteElemDelete,
  TteElemSelect,
  TteElemExtendSelect,
  TteElemActivate,
  TteElemSetReference,
  TteElemInclude,
  TteElemPaste,
  TteElemChange,
  TteElemMove,
  TteElemTextModify,
  TteElemGraphModify,
 
  TtePRuleCreate,
  TtePRuleModify,
  TtePRuleDelete,
 
  TteDocOpen,
  TteDocCreate,
  TteDocClose,
  TteDocSave,
  TteDocExport,
 
  TteViewOpen,
  TteViewClose,
  TteViewResize,
  TteViewScroll,
 
  TteInit,
  TteExit
} TteEvent;
 
</PRE>

<P>The type signature of a <TT>.Pre</TT> action of the application is:</P>
<PRE>
boolean Action(notify)
   Notify *notify;
</PRE>

<P>The type signature of a <TT>.Post</TT> action of the application is:</P>
<PRE>
void Action(notify)
   Notify *notify;
</PRE>

<H2><A NAME="secta7">7</A> <A NAME="L1741">Example</A></H2>

<P>Amaya is an example of appplication built on Thot library. We just explain
here how this application declares a subset of its user interface and a subset
of Thot events using <TT>EDITOR.A</TT> and <TT>HTML.A</TT> files. These
complete files can be found in the  amaya  directory.</P>
<PRE>
APPLICATION EDITOR;
USES
 HTML, Lookup, NoStructSelect;
DEFAULT
   Init.Post -&gt; InitAmaya;

MENUS
   HTML Windows:
 BEGIN
.......
 view:1 Style button:BCreateClass -&gt; ChangeClass;
 view:1 Style button:BApplyClass -&gt; ApplyClass;
 view:1 Style Separator;
 view:1 Style button:BCSS -&gt; InitCSSDialog;
        view:1 Style Separator;
        view:1 Style.Phrase toggle:TEmphasis -&gt; CreateElemEmphasis;
....... 
        view:1 Style.Font toggle:TItalic -&gt; CreateElemItalic;
        view:1 Style.Font toggle:TBold -&gt; CreateElemBold;
        view:1 Style.Font toggle:TTeletype -&gt; CreateElemTeletype;
        view:1 Style.Font toggle:TStrikeOut -&gt; CreateElemStrikeOut;
        view:1 Style.Font toggle:TBig -&gt; CreateElemBig;
        view:1 Style.Font toggle:TSmall -&gt; CreateElemSmall;
        view:1 Style.Font button:BSub -&gt; CreateSub;
        view:1 Style.Font button:BSup -&gt; CreateSup;
 view:1 Style.Font button:BFont -&gt; CreateElemFont;

 Attributes_;

 view:1 Help_ button:BInformation -&gt; HelpAmaya;

 END;
END
 
</PRE>

<P>This <TT>EDITOR.A</TT> file declares in <TT>USES</TT> section that Amaya
loads the other application schema <TT>HTML.A</TT> and the Thot modules: 
Lookup, NoStructSelect.</P>

<P>The <TT>DEFAULT</TT> section allows Amaya to execute the <TT>InitAmaya</TT>
function as initial function.</P>

<P>The <TT>MENUS</TT> section declares only menus specific to HTML documents.
The Style menu is only defined for the view 1 of the HTML presentation
schema.</P>

<P>It  contains:</P>

<UL>
<LI>simple buttons like <TT>BCreateClass</TT> and <TT>BApplyClass</TT>, etc.,
<LI>separators,
<LI>cascade submenus like <TT>Font</TT> submenu which contains simple buttons
and toggle buttons.
</UL>

<P> </P>

<TABLE BORDER=0>
  <TR>

<TD width=50%>

<P><IMG SRC="button.gif" ALT="Image button.gif"></P>

<TD width=50%>

<P>&lt;- Menu Style in View 1</P>

<P>&lt;- Simple buttons</P>

<P></P>

<P>&lt;- Separator</P>

<P></P>

<P></P>

<P>&lt;- Cascade submenu Font</P>

<P>&lt;- Toggles</P>

  </TR>
</TABLE>

<P></P>
<PRE>
APPLICATION HTML;

DEFAULT
   BEGIN
   ElemActivate.Pre -&gt; DoubleClick;
.....
   END;

ELEMENTS

   PICTURE_UNIT:
   BEGIN
   ElemNew.Post -&gt; UpdateSRCattribute;
   ElemTextModify.Post -&gt; UpdateSRCattribute;
   END;

.....
ATTRIBUTES

   SRC:
   BEGIN
   AttrModify.Post -&gt; SRCattrModified;
   END;
.....
 END;
END
</PRE>

<P>The <TT>HTML.A</TT> file declares in <TT>DEFAULT</TT> section that the
Amaya action <TT>DoubleClick</TT> have to be called when user double click any
element in HTML documents. This action is called before Thot do anything. </P>

<P>In section <TT>ELEMENTS</TT>, the <TT>UpdateSRCattribute</TT> function will
be called after the user creates a new picture element or changes the contents
of an existing one.</P>

<P>In section <TT>ATTRIBUTES</TT>, the <TT>SRCattrModified</TT> function will
be called after the attribute SRC is modified.</P>

<H2><A NAME="secta8">8</A> Compiling application schemas to generate
application</H2>

<P>Once application schemas have been written (see example in section <A
HREF="#secta7">7</A>), they must be compiled. To do this, corresponding
structure schemas have to be previously compiled and accessible (application
schema and structure schema have to be located in the same directory).</P>

<P>To compile the <TT>EDITOR.A</TT> schema the developer has to invoke:</P>

<PRE>
app EDITOR
</PRE>

<P>The compiler creates four files:</P>

<UL>
<LI><TT>EDITOR.h</TT>: a file of definitions intended to be included in
modules containing actions. This file defines all menus, submenus and menu
items used in EDITOR.A file.
<LI>EDITORdialogue: an example file of dialogue table which can be connected
to substitute generic names by localized name adapted to the current language.
<LI><TT>EDITORAPP.c</TT>: a file of C code which initializes the application.
This file should not be modified.
<LI><TT>EDITORactions.proto</TT>: a file containing the prototype of all
application functions that have to be implemented. The first time, this file
must then be renamed in <TT>EDITORactions.c</TT> and the body of actions must
be written. Other time, the developer will take in this file only new
functions to add them to its EDITORactions.c file.
</UL>

<P>To compile the <TT>HTML.A</TT> schema the developer has to invoke:</P>

<PRE>
app HTML
</PRE>

<P>The compiler creates three files:</P>

<UL>
<LI><TT>HTML.h</TT>: a file of definitions intended to be included in modules
containing actions. This file defines all the element types and the attributes
contained in the (<TT>HTML.S</TT>) structure schema.
<LI><TT>HTMLAPP.c</TT>: a file of C code which initializes the application.
This file should not be modified.
<LI><TT>HTMLactions.proto</TT>: a file containing the prototype of all
application functions that have to be implemented. The first time, this file
must then be renamed in <TT>EDITORactions.c</TT> and the body of actions must
be written. Other time, the developer will take in this file only new
functions to add them to its HTMLactions.c file.
</UL>

<H2><A NAME="secta9">9</A> Makefile</H2>

<P>Once the code of actions has been written, it can be compiled and linked.
For compiling and  linking, modules generate by the app compiler have to be
included.</P>

<P>We provide a Imakefile for Thot applications which can be extended or used
as example (see makes/Imakefile).</P>

<P>Thot uses a set of libraries which are necessary to successfully compile
and link the application. Some of them are given with the Thot
environment:</P>

<UL>
<LI>libjpeg.a
<LI>libz.a
<LI>libpng.a
<LI>libwww.a (only for Amaya)
</UL>

<P>Other libraries have to be found in your specific environment:</P>

<UL>
<LI>libX11.a or libX11.so
<LI>libXt.a or libXt.so
<LI>libXm.a or libXm.so
</UL>

</BODY>
</HTML>
