! file MathML.trans : structure transformation for MathML
! see HTML.trans for a description of Trans language
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! WARNING : transformations does NOT work with Multiscript elements
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!! Root Transformations

!surround an element with a root
root : *;
	{
	* > MROOT:*;
	* > MROOT:NONE % ;
	}

!surround a sequence of elements with a root
root: *+,last:*;
        {
        * > MROOT.MROW:*;
	last > MROOT.MROW:*;
	last > MROOT:NONE % ;
        }

!remove a root
remove root: MROOT{base:*,? index:*};
        {
        base > :*;
	index / ;
        }


!!! Square Root Transformations

!surround an element with a square root
square root: *;
        {
        * > MSQRT:*;
        }


!surround a sequence of elements with a square root
square root: *,*+;
        {
        * > MSQRT.MROW:*;
        }

!remove a square root
remove square root: MSQRT{*};
        {
        * > :*;
        }


!!! Fraction transformations

!transform 2 elements into a fraction
fraction: (num:*,den:*) | MROW{num:*,den:*};
        {
        num > MFRAC:*;
        den > MFRAC:*;
        }

!transform an  element into a numerator
numerator: *;
        {
        * > MFRAC:*;
        * > MFRAC:NONE %;
        }

!transform an sequence of elements into a numerator
numerator: ?*+,last:*;
        {
        * > MFRAC.MROW:*;
	last > MFRAC.MROW:*;
        last > MFRAC:NONE %;
        }

!transform an element into a denominator
denominator: *;
        {
        * > MFRAC:NONE %;
        * > MFRAC:*;
        }

!transform an sequence of elements into a denominator
denominator: first:*,?*+;
        {
        first > MFRAC:NONE %;
	first > MFRAC.MROW:*;
        * > MFRAC.MROW:*;
        }

!remove a fraction
remove fraction: MFRAC{?(num:*),?(den:*)};
        {
        num > :*;
        den > :*;
        }


!!! Sub and Sup Transformations

!surroud an element with a subsup
add sub and sup:*;
	{
	* > MSUBSUP:*;
	* > MSUBSUP:NONE%;
	* > MSUBSUP:NONE;
	}

!removes a subsup
remove subsup: MSUBSUP{base:*,?sub:*,?sup:*};
	{
	base > :*;
	sub /;
	sup /;
	}

!removes a superscript
remove superscript: MSUBSUP{base:*,?sub:*,?sup:*};
	{
	MSUBSUP > MSUB;
	sup /;
	}

!removes a subscript
remove subscript: MSUBSUP{base:*,?sub:*,?sup:*};
	{
	MSUBSUP > MSUP;
	sub /;
	}

!surroud element with a sub
add subscript:*;
	{
	* > MSUB:*;
	* > MSUB:NONE %;
	}

!removes a subscript
remove subscript: MSUB{base:*,?sub:*};
	{
	base > :*;
	sub /;
	}

!surroud an element with a sup
add superscript:*;
	{
	* > MSUP:*;
	* > MSUP:NONE %;
	}

!removes a superscript
remove superscript: MSUP{base:*,?sup:*};
	{
	base > :*;
	sup /;
	}

!change MSUB into MSUP
superscript:MSUB;
	{
	MSUB > MSUP;
	}

!change MSUP into MSUB
subscript:MSUP;
	{
	MSUP > MSUB;
	}

!change MSUB or MSUP into MSUBSUP
subsup:MSUB{base:*,sub:*} | MSUP{base:*,sup:*};
	{
	base > MSUBSUP:*;
	sup > MSUBSUP:NONE %;
	sup > MSUBSUP:*;
	sub > MSUBSUP:*;
	sub > MSUBSUP:NONE %;
	}

!!! Under and Over transformations

!surroud an element with a underover
add under and over:*;
	{
	* > MUNDEROVER:*;
	* > MUNDEROVER:NONE %;
	* > MUNDEROVER:NONE;
	}

! remove an underover
remove under and over:MUNDEROVER{base:*,?under:*,?over:*};
	{
	base > :*;
	under /;
	over /;
	}
 
!surroud an element with a over
add over:*;
	{
	* > MOVER:*;
	* > MOVER:NONE %;
	}

! remove an over
remove under and over:MOVER{base:*,?over:*};
	{
	base > :*;
	over /;
	}
 
!surroud an element with a under
add under:*;
	{
	* > MUNDER:*;
	* > MUNDER:NONE;
	}

! remove an under
remove under:MUNDER{base:*,?under:*};
	{
	base > :*;
	under /;
	}
 
!!! Parenthesis Transformations

!surround an element with parentheses
parenthesize:*;
        {
        * > MROW:MF."(";
        * > MROW:*;
        * > MROW:MF.")";
        }

!surround a sequence of elements with parentheses
parenthesize: first:*,?*+, last:* ;
        {
        first > MROW:MF."(";
        first > MROW:*;
        * > MROW:*;
        last > MROW:*;
        last > MROW:MF.")";
        }

!remove parenthesis
remove parenthesis: MROW{MF,?*+,MF};
	{
	MF /;
	* > :*;
	}

! remove a Row level
remove row: MROW{*+};
        {
        * > :*;
        }
