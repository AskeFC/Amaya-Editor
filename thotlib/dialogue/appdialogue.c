/*
 * Copyright (c) INRIA 1996-2007
 */

/*
 * Handle windows and menu bars of Thot applications
 *
 * Authors: I. Vatton (INRIA)
 *          R. Guetari (W3C/INRIA) - Windows version
 *          E. Bonnet (INRIA) - GTK combo box & svglib
 *
 */
#ifdef _WX
#include "AmayaFrame.h"
#endif /* _WX */

#include "thot_gui.h"
#include "thot_sys.h"
#include "constmedia.h"
#include "typemedia.h"
#include "appdialogue.h"
#include "dialog.h"

#ifdef _WX
#include "AmayaParams.h"
#include "appdialogue_wx_f.h"
#endif /* _WX */

#include "application.h"
#include "dialog.h"
#include "document.h"
#include "message.h"
#include "libmsg.h"

#define MAX_ARGS	20
#define MaxEquivLen     400

#undef THOT_EXPORT
#define THOT_EXPORT extern
#include "font_tv.h"
#include "edit_tv.h"
#include "modif_tv.h"
#include "select_tv.h"
#include "frame_tv.h"
#include "units_tv.h"
#include "appdialogue_tv.h"
#include "appevents_tv.h"

#include "absboxes_f.h"
#include "actions_f.h"
#include "appdialogue_f.h"
#include "appdialogue_wx_f.h"
#include "applicationapi_f.h"
#include "boxlocate_f.h"
#include "boxparams_f.h"
#include "boxselection_f.h"
#include "buildboxes_f.h"
#include "callback_f.h"
#include "context_f.h"
#include "creationmenu_f.h"
#include "dialogapi_f.h"
#include "dictionary_f.h"
#include "displaybox_f.h"
#include "displayview_f.h"
#include "editcommands_f.h"
#include "textcommands_f.h"
#include "font_f.h"
#include "inites_f.h"

#define MENU_VAL_LENGTH 1000

#include "input_f.h" 
#include "appli_f.h"
#include "profiles_f.h"
#include "thotmsg_f.h"

#include "glwindowdisplay.h"
#include "gltimer.h"

/* function generated by the compiler app */
extern void TteLoadApplications ( void );
//extern ThotBool     WithMessages;	/* partage avec le module dialog.c */
//extern ThotPixmap   image;
extern int          appArgc;
extern char       **appArgv;
extern int          iString;
typedef void        (*Thot_ActionProc) ();
typedef struct _CallbackCTX *PtrCallbackCTX;

typedef struct _CallbackCTX
{
  Thot_ActionProc     callbackProc;
  int                 callbackSet;
  PtrCallbackCTX      callbackNext;
}
CallbackCTX;

static PtrCallbackCTX FirstCallbackAPI;
static int          FreeMenuAction;
#ifndef _WX
static  Proc 	    LastProcedure = NULL;
#endif /* _WX */
static  ThotBool    ActivatedButton = FALSE;   
static ThotBool     g_DoingAction = FALSE;

void InitClue (ThotWidget toplevel);


/*----------------------------------------------------------------------
  TteInitMenuActions alloue la table des actions.                    
  ----------------------------------------------------------------------*/
void TteInitMenus (char *name, int number)
{
  char               *profile = NULL;
  int                 i;

  /* Initialisation du  contexte serveur */
#ifndef _WX
  FrRef[0] = 0;
#endif /* #ifndef _WX */
  InitDocContexts ();
  /* Initialise le dialogue */
  servername = NULL;
  if (appArgc > 2)
    {
      i = 1;
      while (i < appArgc - 1)
        if (!strcmp (appArgv[i], "-display"))
          /* the display name is the following argument */
          servername = appArgv[++i];
        else if (!strcmp (appArgv[i], "-profile"))
          /* the profile name is the following argument */
          profile = appArgv[++i];
        else
          i++;
    }
  /* Init the profile table */
  Prof_InitTable (profile);
  TtaInitDialogue (servername, &app_cont);
  /* Definition de la procedure de retour des dialogues */
  TtaDefineDialogueCallback ((Proc)ThotCallback);
  Dict_Init ();
  ThotInitDisplay (name, 0, 0);
   
  /* reserve Thot entries */
  TtaGetReferencesBase (MAX_ThotMenu);

  /* Il faut ajouter les actions internes liees a la structure */
  number += MAX_INTERNAL_CMD;

  MaxMenuAction = number;
  MenuActionList = (Action_Ctl *) TtaGetMemory (number * sizeof (Action_Ctl));
  /* initialisation des equilalents clavier et validation de l'action */
  for (FreeMenuAction = 0; FreeMenuAction < MAX_INTERNAL_CMD; FreeMenuAction++)
    {
      MenuActionList[FreeMenuAction].ActionEquiv = NULL;
#ifdef _WX
      for (i = 0; i < MAX_DOCUMENTS; i++)
        MenuActionList[FreeMenuAction].ActionActive[i] = TRUE;
#else /* _WX */
      for (i = 0; i < MAX_FRAME; i++)
        MenuActionList[FreeMenuAction].ActionActive[i] = TRUE;
#endif /* _WX */
    }
  for (i = FreeMenuAction; i < MaxMenuAction; i++)
    {
      MenuActionList[i].ActionName = "";
      MenuActionList[i].Call_Action = (Proc) NULL;
      MenuActionList[i].ActionEquiv = NULL;
    }

  /* Initialisation des actions internes obligatoires */
  MenuActionList[0].ActionName = "TtcInsertChar";	/* action InsertChar() */
  MenuActionList[0].Call_Action = (Proc) NULL;

  MenuActionList[CMD_DeletePrevChar].ActionName = "TtcDeletePreviousChar";
  MenuActionList[CMD_DeletePrevChar].Call_Action = (Proc) NULL;
  MenuActionList[CMD_DeletePrevChar].ActionEquiv = TtaStrdup ("BackSpace");

  MenuActionList[CMD_DeleteSelection].ActionName = "TtcDeleteSelection";
  MenuActionList[CMD_DeleteSelection].Call_Action = (Proc) NULL;
  MenuActionList[CMD_DeleteSelection].ActionEquiv = TtaStrdup ("Delete");

  MenuActionList[CMD_PreviousChar].ActionName = "TtcPreviousChar";
  MenuActionList[CMD_PreviousChar].Call_Action = (Proc) TtcPreviousChar;

  MenuActionList[CMD_NextChar].ActionName = "TtcNextChar";
  MenuActionList[CMD_NextChar].Call_Action = (Proc) TtcNextChar;

  MenuActionList[CMD_PreviousLine].ActionName = "TtcPreviousLine";
  MenuActionList[CMD_PreviousLine].Call_Action = (Proc) TtcPreviousLine;

  MenuActionList[CMD_NextLine].ActionName = "TtcNextLine";
  MenuActionList[CMD_NextLine].Call_Action = (Proc) TtcNextLine;

  MenuActionList[CMD_PreviousWord].ActionName = "TtcPreviousWord";
  MenuActionList[CMD_PreviousWord].Call_Action = (Proc) TtcPreviousWord;

  MenuActionList[CMD_NextWord].ActionName = "TtcNextWord";
  MenuActionList[CMD_NextWord].Call_Action = (Proc) TtcNextWord;

  MenuActionList[CMD_BeginningOfLine].ActionName = "TtcStartOfLine";
  MenuActionList[CMD_BeginningOfLine].Call_Action = (Proc) TtcStartOfLine;

  MenuActionList[CMD_SelBeginningOfLine].ActionName = "TtcSelStartOfLine";
  MenuActionList[CMD_SelBeginningOfLine].Call_Action = (Proc) TtcSelStartOfLine;

  MenuActionList[CMD_SelEndOfLine].ActionName = "TtcSelEndOfLine";
  MenuActionList[CMD_SelEndOfLine].Call_Action = (Proc) TtcSelEndOfLine;


  MenuActionList[CMD_EndOfLine].ActionName = "TtcEndOfLine";
  MenuActionList[CMD_EndOfLine].Call_Action = (Proc) TtcEndOfLine;

  MenuActionList[CMD_ParentElement].ActionName = "TtcParentElement";
  MenuActionList[CMD_ParentElement].Call_Action = (Proc) TtcParentElement;

  MenuActionList[CMD_PreviousElement].ActionName = "TtcPreviousElement";
  MenuActionList[CMD_PreviousElement].Call_Action = (Proc) TtcPreviousElement;

  MenuActionList[CMD_NextElement].ActionName = "TtcNextElement";
  MenuActionList[CMD_NextElement].Call_Action = (Proc) TtcNextElement;

  MenuActionList[CMD_ChildElement].ActionName = "TtcChildElement";
  MenuActionList[CMD_ChildElement].Call_Action = (Proc) TtcChildElement;

  MenuActionList[CMD_PageUp].ActionName = "TtcPageUp";
  MenuActionList[CMD_PageUp].Call_Action = (Proc) TtcPageUp;
  MenuActionList[CMD_PageUp].ActionEquiv = TtaStrdup ("Prior");

  MenuActionList[CMD_PageDown].ActionName = "TtcPageDown";
  MenuActionList[CMD_PageDown].Call_Action = (Proc) TtcPageDown;
  MenuActionList[CMD_PageDown].ActionEquiv = TtaStrdup ("Next");

  MenuActionList[CMD_PageTop].ActionName = "TtcPageTop";
  MenuActionList[CMD_PageTop].Call_Action = (Proc) TtcPageTop;
  MenuActionList[CMD_PageTop].ActionEquiv = TtaStrdup ("Home");

  MenuActionList[CMD_PageEnd].ActionName = "TtcPageEnd";
  MenuActionList[CMD_PageEnd].Call_Action = (Proc) TtcPageEnd;
  MenuActionList[CMD_PageEnd].ActionEquiv = TtaStrdup ("End");

  MenuActionList[CMD_LineUp].ActionName = "TtcLineUp";
  MenuActionList[CMD_LineUp].Call_Action = (Proc) TtcLineUp;
  MenuActionList[CMD_LineUp].ActionEquiv = TtaStrdup ("C Left");

  MenuActionList[CMD_LineDown].ActionName = "TtcLineDown";
  MenuActionList[CMD_LineDown].Call_Action = (Proc) TtcLineDown;
  MenuActionList[CMD_LineDown].ActionEquiv = TtaStrdup ("C Down");

  MenuActionList[CMD_ScrollRight].ActionName = "TtcScrollRight";
  MenuActionList[CMD_ScrollRight].Call_Action = (Proc) TtcScrollRight;
  MenuActionList[CMD_ScrollRight].ActionEquiv = TtaStrdup ("C Right");

  MenuActionList[CMD_ScrollLeft].ActionName = "TtcScrollLeft";
  MenuActionList[CMD_ScrollLeft].Call_Action = (Proc) TtcScrollLeft;
  MenuActionList[CMD_ScrollLeft].ActionEquiv = TtaStrdup ("C Left");

  MenuActionList[CMD_CreateElement].ActionName = "TtcCreateElement";
  MenuActionList[CMD_CreateElement].Call_Action = (Proc) NULL;

  MenuActionList[CMD_LineBreak].ActionName = "TtcInsertLineBreak";
  MenuActionList[CMD_LineBreak].Call_Action = (Proc) TtcInsertLineBreak;
  MenuActionList[CMD_LineBreak].ActionEquiv = TtaStrdup ("C Return");

  MenuActionList[CMD_CopyToClipboard].ActionName = "TtcCopyToClipboard";
  MenuActionList[CMD_CopyToClipboard].Call_Action = (Proc) TtcCopyToClipboard;

  MenuActionList[CMD_PasteFromClipboard].ActionName = "TtcPasteFromClipboard";
  MenuActionList[CMD_PasteFromClipboard].Call_Action = (Proc) NULL;

  MenuActionList[CMD_PreviousSelChar].ActionName = "TtcPreviousSelChar";
  MenuActionList[CMD_PreviousSelChar].Call_Action = (Proc) TtcPreviousSelChar;

  MenuActionList[CMD_NextSelChar].ActionName = "TtcNextSelChar";
  MenuActionList[CMD_NextSelChar].Call_Action = (Proc) TtcNextSelChar;

  MenuActionList[CMD_PreviousSelLine].ActionName = "TtcPreviousSelLine";
  MenuActionList[CMD_PreviousSelLine].Call_Action = (Proc) TtcPreviousSelLine;

  MenuActionList[CMD_NextSelLine].ActionName = "TtcNextSelLine";
  MenuActionList[CMD_NextSelLine].Call_Action = (Proc) TtcNextSelLine;

  MenuActionList[CMD_PreviousSelWord].ActionName = "TtcPreviousSelWord";
  MenuActionList[CMD_PreviousSelWord].Call_Action = (Proc) TtcPreviousSelWord;

  MenuActionList[CMD_NextSelWord].ActionName = "TtcNextSelWord";
  MenuActionList[CMD_NextSelWord].Call_Action = (Proc) TtcNextSelWord;

  MenuActionList[CMD_Copy].ActionName = "TtcCopySelection";
  MenuActionList[CMD_Copy].Call_Action = (Proc) TtcCopySelection;

  MenuActionList[CMD_Paste].ActionName = "TtcPaste";
  MenuActionList[CMD_Paste].Call_Action = (Proc) TtcPaste;

  MenuActionList[CMD_CutSelection].ActionName = "TtcCutSelection";
  MenuActionList[CMD_CutSelection].Call_Action = (Proc) TtcCutSelection;
}

/*----------------------------------------------------------------------
  TtaGetMenuActionNumber returns the number of actions
  ----------------------------------------------------------------------*/
int TtaGetMenuActionNumber()
{
  return FreeMenuAction;
}

/*----------------------------------------------------------------------
  FreeMenus frees all contextes allocated by the menu manager
  ----------------------------------------------------------------------*/
void FreeMenus ()
{
  PtrAction           pAction, aNext;
  Menu_Ctl           *ptrmenu, *mNext;
  Item_Ctl           *ptrItem;
  PtrCallbackCTX      ctxCallback;
  int                 i;

  /* free menu actions */
  if (MenuActionList)
    {
      for (i = 0; i < FreeMenuAction; i++)
        {
          TtaFreeMemory (MenuActionList[i].ActionEquiv);
          MenuActionList[i].ActionEquiv = NULL;
        }
      for (i = MAX_INTERNAL_CMD; i < FreeMenuAction; i++)
        {
          TtaFreeMemory (MenuActionList[i].ActionName);
          MenuActionList[i].ActionName = NULL;
        }
      TtaFreeMemory (MenuActionList);
      MenuActionList = NULL;
    }
  FreeMenuAction = 0;

  /* free menu contexts allocated for standard documents*/
  ptrmenu = DocumentMenuList;
  DocumentMenuList = NULL;
  while (ptrmenu)
    {
      ptrItem = ptrmenu->ItemsList;
      for (i = 0; i < ptrmenu->ItemsNb; i++)
        if (ptrItem[i].ItemType == 'M')
          {
            /* free a submenu */
            TtaFreeMemory (ptrItem[i].SubMenu->ItemsList);
            TtaFreeMemory (ptrItem[i].SubMenu);
          }
	  
      /* free the items list */
      TtaFreeMemory (ptrItem);
      /* free the menu context */
      mNext = ptrmenu->NextMenu;
      TtaFreeMemory (ptrmenu);
      ptrmenu = mNext;
    }
    
  /* free actions */
  pAction = ActionList;
  ActionList = NULL;
  while (pAction != NULL)
    {
      aNext = pAction->ActNext;
      TtaFreeMemory (pAction);
      pAction = aNext;
    }

  /* free callback contexts */
  ctxCallback = FirstCallbackAPI;
  while (ctxCallback)
    {
      FirstCallbackAPI = ctxCallback->callbackNext;
      TtaFreeMemory (ctxCallback);
      ctxCallback = FirstCallbackAPI;
    }
}


/*----------------------------------------------------------------------
  TteAddMenuAction ajoute une nouvelle action dans la table des      
  actions d'interface.                                            
  ----------------------------------------------------------------------*/
void TteAddMenuAction (char *actionName, Proc procedure, ThotBool state)
{
  char               *ptr;
  int                 lg;
  int                 i;

  if (actionName == NULL/* || !Prof_BelongTable (actionName)*/)
    return;			/* pas de nom d'action declare */

  lg = strlen (actionName);
  if (FreeMenuAction < MaxMenuAction && lg != 0)
    {
      /* Alloue une chaine de caractere pour le nom de l'action */
      ptr = (char *)TtaGetMemory (lg + 1);
      strcpy (ptr, actionName);
      MenuActionList[FreeMenuAction].ActionName = ptr;
      MenuActionList[FreeMenuAction].Call_Action = procedure;
      MenuActionList[FreeMenuAction].ActionEquiv = NULL;
      /* Cette nouvelle action n'est active pour aucune frame */
#ifdef _WX
      for (i = 0; i < MAX_DOCUMENTS; i++)
        MenuActionList[FreeMenuAction].ActionActive[i] = state;
#else /* _WX */
      for (i = 0; i < MAX_FRAME; i++)
        MenuActionList[FreeMenuAction].ActionActive[i] = state;
#endif /* _WX */
      FreeMenuAction++;
    }
}


/*----------------------------------------------------------------------
  FindMenuAction returns the entry that describes the menu action.
  ----------------------------------------------------------------------*/
int FindMenuAction (const char *actionName)
{
  int                 i;

  for (i = 0; i < MaxMenuAction; i++)
    {
      if (!strcmp (actionName, MenuActionList[i].ActionName))
        return (i);
    }
  return (i);
}

/*----------------------------------------------------------------------
  FindMenuItemIDFromMenuAction returns the menu item id corresponding to the action id.
  notice: only used in WX version
  ----------------------------------------------------------------------*/
int FindMenuItemIDFromMenuAction (Menu_Ctl * ptrmenu, int action_id)
{
  int        menu_id = -1;
  Item_Ctl * ptritem = NULL;
  int        item_nb = 0;
  char       item_type = ' ';

  if (!ptrmenu)
    ptrmenu = DocumentMenuList;

  /* loop on menus */
  while ( (menu_id == -1) && ptrmenu )
    {
      ptritem = ptrmenu->ItemsList;
      item_nb = 0;

      /* loop on menu items */
      while ( (menu_id == -1) && (item_nb < ptrmenu->ItemsNb) )
        {
          item_type = ptritem[item_nb].ItemType;
          switch (item_type)
            {
            case 'B':
            case 'T':
              if (ptritem[item_nb].ItemAction == action_id)
                menu_id = ptritem[item_nb].ItemID;
              break;

            case 'S':
              break;

            case 'M':
              menu_id = FindMenuItemIDFromMenuAction(ptritem[item_nb].SubMenu, action_id);
              break;

            default:
#ifdef _WX
              wxASSERT_MSG(FALSE, _T("The menu item type is not supported."));
#endif /* _WX */
              break;
            }
          item_nb++;
        }
      
      ptrmenu = ptrmenu->NextMenu;
    }
  return menu_id;
}

/*----------------------------------------------------------------------
  FindMenuActionFromMenuItemID returns the action id corresponding to the menu item id.
  notice: only used in WX version
  ----------------------------------------------------------------------*/
int FindMenuActionFromMenuItemID (Menu_Ctl * ptrmenu, int item_id)
{
  int        action_id = -1;
  Item_Ctl * ptritem = NULL;
  int        item_nb = 0;
  char       item_type = ' ';

  if (!ptrmenu)
    ptrmenu = DocumentMenuList;

  /* loop on menus */
  while ( (action_id == -1) && ptrmenu )
    {
      ptritem = ptrmenu->ItemsList;
      item_nb = 0;

      /* loop on menu items */
      while ( (action_id == -1) && (item_nb < ptrmenu->ItemsNb) )
        {
          item_type = ptritem[item_nb].ItemType;
          switch (item_type)
            {
            case 'B':
            case 'T':
              if (ptritem[item_nb].ItemID == item_id)
                action_id = ptritem[item_nb].ItemAction;
              break;

            case 'S':
              break;

            case 'M':
              action_id = FindMenuActionFromMenuItemID(ptritem[item_nb].SubMenu, item_id);
              break;

            default:
#ifdef _WX
              wxASSERT_MSG(FALSE, _T("The menu item type is not supported."));
#endif /* _WX */
              break;
            }
          item_nb++;
        }
      
      ptrmenu = ptrmenu->NextMenu;
    }
  return action_id;
}


/*----------------------------------------------------------------------
  TtaExecuteMenuActionFromActionId execute the corresponding menu action.
  When force is TRUE the action is called even if it's not active.
  ----------------------------------------------------------------------*/
void TtaExecuteMenuActionFromActionId (int action_id, Document doc,
                                       View view, ThotBool force)
{
  int                 frame_id, ref;
  
  // prevent recursive call
  if (g_DoingAction)
    return;
  g_DoingAction = TRUE;

  UserErrorCode = 0;
  if (doc == 0 || view == 0 || action_id <= 0)
    TtaError (ERR_invalid_parameter);
  else
    {
      frame_id = GetWindowNumber (doc, view);
#ifdef _WX
      ref = doc;
#else /* _WX */
      ref = frame_id;
#endif /* _WX */

     if (action_id > 0 && action_id < MaxMenuAction &&
         (MenuActionList[action_id].ActionActive[ref] || force) &&
         MenuActionList[action_id].Call_Action)
       {
         if (!SelPosition ||
             (strcmp (MenuActionList[action_id].ActionName, "TtcDeletePreviousChar") &&
              strcmp (MenuActionList[action_id].ActionName, "TtcDeleteSelection")))
           CloseTextInsertion ();
#ifdef _WX
         // redirect focus to the canvas because when an action is done 
         // it's more probable that the user wants to type some characteres after executing the action
         TtaRedirectFocus();
         g_DoingAction = FALSE;
#endif /* _WX */
         (*(Proc2)MenuActionList[action_id].Call_Action) ((void *)doc, (void *)view);
       }
     else
       TtaRedirectFocus();
    }
  g_DoingAction = FALSE;
}

/*----------------------------------------------------------------------
  TtaExecuteMenuAction execute the corresponding menu action.
  ----------------------------------------------------------------------*/
void TtaExecuteMenuAction (const char *actionName, Document doc, View view,
                           ThotBool force)
{
  int                 action_id;

  /* verifie le parametre document */
  if (doc == 0 || view == 0 || actionName == NULL)
    TtaError (ERR_invalid_parameter);
  else
    {
      action_id = FindMenuAction (actionName);
      TtaExecuteMenuActionFromActionId (action_id, doc, view, force);
    }
}


/*----------------------------------------------------------------------
  TteZeroMenu signale qu'il n'y a pas de menu dans ce type de        
  fenentre.                                                       
  ----------------------------------------------------------------------*/
void TteZeroMenu ()
{
}


/*----------------------------------------------------------------------
  TteAddMenu ajoute un nouveau menu pour le schema donne. Si le      
  nom de schema est Null, il s'agit des menus pris par defaut.    
  ----------------------------------------------------------------------*/
void TteAddMenu (int view, int menuID, int itemsNumber, char *menuName)
{
  Menu_Ctl           *ptrmenu = NULL;
  Menu_Ctl           *newmenu;
  Item_Ctl           *ptr;
  int                 i;

  /* Creation du nouveau menu */
  newmenu = (Menu_Ctl *) TtaGetMemory (sizeof (Menu_Ctl));
  newmenu->MenuID = menuID;
  newmenu->MenuView = view;
  newmenu->ItemsNb = itemsNumber;
  /* Enregistre les menus actifs */
  newmenu->MenuAttr = FALSE;
  newmenu->MenuSelect = FALSE;
  newmenu->MenuHelp = FALSE;
  newmenu->MenuContext = FALSE;
  newmenu->MenuDocContext = FALSE;
  if (!strcmp (menuName, "MenuAttribute"))
    newmenu->MenuAttr = TRUE;
  else if (!strcmp (menuName, "MenuSelection"))
    newmenu->MenuSelect = TRUE;
  else if (!strcmp (menuName, "MenuHelp"))
    newmenu->MenuHelp = TRUE;
  else if (!strcmp (menuName, "MenuContext"))
    newmenu->MenuContext = TRUE;
  else if (!strcmp (menuName, "MenuDocContext"))
    newmenu->MenuDocContext = TRUE;
   
  /* creation et initialisation de la table des items */
  ptr = (Item_Ctl *)TtaGetMemory (itemsNumber * sizeof (Item_Ctl));
  for (i = 0; i < itemsNumber; i++)
    {
      ptr[i].ItemID = -1;
      ptr[i].ItemAction = -1;
      ptr[i].ItemType = SPACE;
    }
  newmenu->ItemsList = ptr;
  newmenu->NextMenu = NULL;

  /* Chainage du nouveau menu aux autres menus existants */
  /* il s'agit d'un des menus pris par defaut */
  if (DocumentMenuList == NULL)
    {
      DocumentMenuList = newmenu;
      ptrmenu = NULL;
    }
  else
    ptrmenu = DocumentMenuList;	/* simple ajout du menu dans une liste */

  if (ptrmenu != NULL)
    {
      /* Ajout du nouveau menu en fin de liste */
      while (ptrmenu->NextMenu != NULL)
        ptrmenu = ptrmenu->NextMenu;
      ptrmenu->NextMenu = newmenu;
    }
}


/*----------------------------------------------------------------------
  TteAddSubMenu ajoute un sous-menu pour le schema donne.            
  ----------------------------------------------------------------------*/
void TteAddSubMenu( int menuID,	int itemID, int itemsNumber )
{
  Menu_Ctl           *ptrmenu;
  Menu_Ctl           *newmenu;
  Item_Ctl           *ptr, *ptrItem;
  int                 i, j;

  /* Recherche la bonne liste de menus */
  ptrmenu = NULL;
  /* il s'agit d'un des menus pris par defaut */
  if (DocumentMenuList != NULL)
    ptrmenu = DocumentMenuList;

  /* Recherche le bon menu */
  while (ptrmenu != NULL && menuID != ptrmenu->MenuID)
    ptrmenu = ptrmenu->NextMenu;

  if (ptrmenu != NULL)
    {
      /* recherche l'item dans le menu */
      ptrItem = ptrmenu->ItemsList;
      j = 0;
      while (j < ptrmenu->ItemsNb && ptrItem[j].ItemType != SPACE)
        j++;
      if (j < ptrmenu->ItemsNb)
        {
          /* Creation du sous-menu */
          newmenu = (Menu_Ctl *) TtaGetMemory (sizeof (Menu_Ctl));
          newmenu->MenuID = 0;
          newmenu->MenuView = 0;
          newmenu->ItemsNb = itemsNumber;
          newmenu->MenuAttr = FALSE;
          newmenu->MenuSelect = FALSE;
          newmenu->MenuHelp = FALSE;
          newmenu->MenuContext = FALSE;
          newmenu->MenuDocContext = FALSE;

          /* creation et initialisation de la table des items */
          ptr = (Item_Ctl *) TtaGetMemory (itemsNumber * sizeof (Item_Ctl));
          for (i = 0; i < itemsNumber; i++)
            {
              ptr[i].ItemID = -1;
              ptr[i].ItemAction = -1;
              ptr[i].ItemType = SPACE;
            }
          newmenu->ItemsList = ptr;
          newmenu->NextMenu = NULL;
          /* relie le sous-menu a l'item */
          ptrItem[j].SubMenu = newmenu;
          ptrItem[j].ItemID = itemID;
          ptrItem[j].ItemType = 'M';
        }
    }
}


/*----------------------------------------------------------------------
  TteAddMenuItem ajoute une nouvel item dans un menu.                
  ----------------------------------------------------------------------*/
void TteAddMenuItem (int menuID, int subMenu, int itemID, const char *actionName, char itemType, const char * iconName)
{
  Menu_Ctl           *ptrmenu;
  Item_Ctl           *ptr;
  int                 i;

  /* Recherche la bonne liste de menus */
  ptrmenu = NULL;
  /* il s'agit d'un des menus pris par defaut */
  if (DocumentMenuList != NULL)
    ptrmenu = DocumentMenuList;
       
  /* Recherche le menu */
  while (ptrmenu != NULL && menuID != ptrmenu->MenuID)
    ptrmenu = ptrmenu->NextMenu;
       
  if (ptrmenu != NULL && subMenu != -1)
    {
      /* Recherche l'entree du sous-menu dans le menu */
      i = 0;
      ptr = ptrmenu->ItemsList;
      while (i < ptrmenu->ItemsNb && (ptr[i].ItemID != subMenu))
        i++;
      if (i < ptrmenu->ItemsNb)
        ptrmenu = ptr[i].SubMenu;
      else
        /* on n'a pas trouve le sous-menu */
        return;
    }
 

  /* checks if the item is present in the user profile */
  if (actionName == NULL || Prof_BelongTable (actionName))
    { 
      /* ajoute l'item dans le menu */
      i = 0;
      ptr = ptrmenu->ItemsList;
      while (i < ptrmenu->ItemsNb && ptr[i].ItemType != SPACE)
        i++;
      if (i < ptrmenu->ItemsNb)
        {
          /* Remove the separaror if the previous element was one */
          if (! (itemType == 'S' && (i == 0 || ptr[i-1].ItemType == 'S')))
            {
              ptr[i].ItemID = itemID;
              ptr[i].ItemType = itemType;
              if (actionName != NULL)
                ptr[i].ItemAction = FindMenuAction (actionName);
              if (iconName != NULL)
                strcpy(ptr[i].ItemIconName, iconName);
              else
                ptr[i].ItemIconName[0] = '\0';
            }
          else
            /* Remove separator */
            ptrmenu->ItemsNb--;
        }
    }
  else
    {
      /* removes the entry */
      ptrmenu->ItemsNb--;
    }       
}


#ifndef _WX
/*----------------------------------------------------------------------
  BuildSubmenu builds or updates a submenu attached to the item in a
  pulldown menu ref.
  The parameter RO is TRUE when only ReadOnly functions are accepted
  ----------------------------------------------------------------------*/
static void BuildSubMenu (Menu_Ctl *ptrmenu, int ref, int entry,
                          int frame, Document doc, ThotBool update,
                          ThotBool RO)
{
  char                string[MENU_VAL_LENGTH];
  char                equiv[MaxEquivLen];
  Item_Ctl           *ptritem;
  char               *ptr;
  char                LastItemType = 'S';
  int                 i, j, state;
  int                 lg, sref, max_lg;
  int                 item, profile;
  int                 action, entries, index;
  ThotBool            withEquiv, hidden;

  /* Construit le sous-menu attache a l'item */
#ifdef _WINGUI
  currentFrame = frame;
#endif /* _WINGUI */
  item = 0;
  i = 0;
  j = 0;
  withEquiv = FALSE;
  equiv[0] = EOS;
  string[0] = EOS;
  entries = 0;
  index = 0;
  ptritem = ptrmenu->ItemsList;
  max_lg = 0;
  /*
    In the previous version hidden entries were removed,
    now all entries are generated and we just invalid
    hidden entries.
  */
  if (update)
    profile = TtaGetDocumentProfile (doc);
  else
    profile = 0; /* no check */
  /* reference of this menu */
  sref = ((entry + 1) * MAX_MENU * MAX_ITEM) + ref;
  while (item < ptrmenu->ItemsNb)
    {
      /* Regarde si le texte des commandes ne deborde pas */
      ptr = TtaGetMessage (THOT, ptritem[item].ItemID);
      lg = strlen (ptr) + 1;
      /* get the larger entry */
      if (max_lg < lg)
        max_lg = lg;
      hidden = FALSE;
      action = ptritem[item].ItemAction;
      if (ptritem[item].ItemType == 'S' && i + 2 < MENU_VAL_LENGTH)
        {
          if (Prof_ShowSeparator(ptrmenu, item, LastItemType))
            {
              strcpy (&string[i], "S");
              i += 2;
            }
          else
            {
              hidden = TRUE;
              action = -1;
            }
        }
      else if (i + lg < 699)
        {
          if (update)
            {
              /* this entry can be displayed */
              state = Prof_BelongDoctype (MenuActionList[action].ActionName,
                                          profile, RO);
              if (state == 0)
                {
                  /* desactivate the entry */
                  TtaRedrawMenuEntry (sref, index, NULL, InactiveB_Color, 0);
                  MenuActionList[action].ActionActive[frame] = FALSE;
                  /* doesn't count this entry */
                  hidden = TRUE;
                  action = -1;
                }
              else if (state == 1)
                {
                  /* activate the entry */
                  TtaRedrawMenuEntry (sref, index, NULL, (ThotColor)-1, 1);
                  MenuActionList[action].ActionActive[frame] = TRUE;
                }
            }
          if (ptritem[item].ItemType == 'D')
            string[i] = 'B';
          else
            string[i] = ptritem[item].ItemType;
          strcpy (&string[i + 1], ptr);
          i += lg + 1;
        }
      else
        {
          /* sinon on reduit le nombre d'items */
          ptrmenu->ItemsNb = item - 1;
          hidden = TRUE;
          action = -1;
        }
      
      /* traite le contenu de l'item de menu */
      if (!update && action != -1 && action < MaxMenuAction)
        {
          /* a new entry is generated */
          if (MenuActionList[action].ActionEquiv != NULL)
            {
              withEquiv = TRUE;
              lg = strlen (MenuActionList[action].ActionEquiv);
              if (lg + j < MaxEquivLen)
                {
                  strcpy (&equiv[j], MenuActionList[action].ActionEquiv);
                  j += lg;
                }
            }
          /* activate this entry */
          MenuActionList[action].ActionActive[frame] = TRUE;
        }
      if (!hidden)
        {
          equiv[j++] = EOS;
          LastItemType = ptrmenu->ItemsList[item].ItemType;
          entries++;
        }
      index++;
      item++;
    }

  /* Creation of the submenu with or whithout equiv */
  if (entries == 0)
    TtaRedrawMenuEntry (ref, entry, NULL, InactiveB_Color, 0);
  else if (update)
    TtaRedrawMenuEntry (ref, entry, NULL, (ThotColor)-1, 1);
  else if (withEquiv)
    TtaNewSubmenu (sref, ref, entry, NULL, entries, string, equiv, max_lg, FALSE);
  else
    TtaNewSubmenu (sref, ref, entry, NULL, entries, string, NULL, max_lg, FALSE);
}
#endif /* _WX */

/*----------------------------------------------------------------------
  BuildPopdown builds or updates a pulldown menu ref attached to the
  document doc.
  The parameter RO is TRUE when only ReadOnly functions are accepted
  ----------------------------------------------------------------------*/
void BuildPopdown ( Menu_Ctl *ptrmenu, int ref, ThotMenu button,
                    int frame, int doc, ThotBool update, ThotBool RO)
{
#ifdef _WX
  wxASSERT_MSG(FALSE, _T("Unused function"));
#endif /* _WX */
#ifndef _WX
  Item_Ctl           *ptritem;
  char                string[MENU_VAL_LENGTH];
  char                equiv[MaxEquivLen];
  char               *ptr;
  char                LastItemType = 'S';
  int                 i, j;
  int                 lg, profile, max_lg;
  int                 item, entries;
  int                 action, state;
  ThotBool            withEquiv, emptyMenu;
  ThotBool            removedsep, hidden;
  PtrDocument         pDoc = LoadedDocument[doc - 1];
  
#ifdef _WINGUI 
  currentFrame = frame;
#endif /* _WINGUI */
  /* Construit le pulldown attache au bouton */
  item = 0;
  entries = 0;
  i = 0;
  j = 0;
  max_lg = 0;
  withEquiv = FALSE;
  equiv[0] = EOS;
  removedsep = FALSE;
  ptritem = ptrmenu->ItemsList;
  /*
    In the previous version hidden entries were removed,
    now all entries are generated and we just invalid
    hidden entries.
  */
  if (update)
    profile = TtaGetDocumentProfile (doc);
  else
    profile = 0; /* no check */
  while (item < ptrmenu->ItemsNb)
    {
      emptyMenu = FALSE;
      hidden = FALSE;
      /* Regarde si le texte des commandes ne deborde pas */
      ptr = TtaGetMessage (THOT, ptritem[item].ItemID);
      lg = strlen (ptr) + 1;
      /* get the larger entry */
      if (max_lg < lg)
        max_lg = lg;
      action = ptritem[item].ItemAction;
      if (ptritem[item].ItemType == 'S' && i + 2 < MENU_VAL_LENGTH)
        {
          /* a separator */
          if (Prof_ShowSeparator(ptrmenu, item, LastItemType))
            {
              strcpy (&string[i], "S");
              i += 2;
            }
          else
            removedsep = TRUE;
        }
      else if (i + lg < 699)
        {
          if (ptritem[item].ItemType == 'M')
            {
              /* a sub-menu */
              if (ptritem[item].SubMenu->ItemsNb == 0)
                emptyMenu = TRUE;
              else
                {
                  string[i] = 'M';
                  strcpy (&string[i + 1], ptr);
                  i += lg + 1;
                }
              action = -1;
            }
          else
            {
              if (update)
                {
                  state = Prof_BelongDoctype (MenuActionList[action].ActionName,
                                              profile, RO);
                  if (state == 0)
                    {
                      /* desactivate the entry */
                      TtaRedrawMenuEntry (ref, entries, NULL, InactiveB_Color, 0);
                      MenuActionList[action].ActionActive[frame] = FALSE;
                      action = -1;
                    }
                  else if (state == 1)
                    {
                      /* activate the entry */
                      TtaRedrawMenuEntry (ref, entries, NULL, (ThotColor)-1, 1);
                      MenuActionList[action].ActionActive[frame] = TRUE;
                    }
                }
              /* generate a button */
              if (ptritem[item].ItemType == 'D')
                string[i] = 'B';
              else
                string[i] = ptritem[item].ItemType;
              strcpy (&string[i + 1], ptr);
              i += lg + 1;
            }
        }
      else
        {
          /* reduce the number of items */
          ptrmenu->ItemsNb = item - 1;
          action = -1;
        }
      
      if (!update && action != -1 && action < MaxMenuAction)
        {
          /* a new entry is generated */
          if (ptritem[item].ItemType == 'B' || ptritem[item].ItemType == 'T')
            {
              if (MenuActionList[action].ActionEquiv)
                {
                  withEquiv = TRUE;
                  lg = strlen (MenuActionList[action].ActionEquiv);
                  if (lg + j < MaxEquivLen)
                    {
                      strcpy (&equiv[j], MenuActionList[action].ActionEquiv);
                      j += lg;
                    }
                }

              /* activate this entry */
              MenuActionList[action].ActionActive[frame] = TRUE;
              /* Is it the Paste command */
              if (!strcmp (MenuActionList[action].ActionName, "TtcPaste"))
                {
                  FrameTable[frame].MenuPaste = ref;
                  FrameTable[frame].EntryPaste = entries;
                }
              /* Is it the Undo command */
              else if (!strcmp (MenuActionList[action].ActionName, "TtcUndo"))
                {
                  FrameTable[frame].MenuUndo = ref;
                  FrameTable[frame].EntryUndo = entries;
                  MenuActionList[action].ActionActive[frame] = FALSE;
                }
              /* Is it the Redo command */
              else if (!strcmp (MenuActionList[action].ActionName, "TtcRedo"))
                {
                  FrameTable[frame].MenuRedo = ref;
                  FrameTable[frame].EntryRedo = entries;
                  MenuActionList[action].ActionActive[frame] = FALSE;
                }
            }
        }

      if (!emptyMenu && !removedsep && !hidden)
        {
          LastItemType = ptrmenu->ItemsList[item].ItemType;
          equiv[j++] = EOS;
          entries++;
        }
      item++;
    }

  if (!update)
    {
      /* Creation of the corresponding Pulldown with or without equiv */
      if (withEquiv)
        TtaNewPulldown (ref, button, NULL, entries, string, equiv, max_lg);
      else
        TtaNewPulldown (ref, button, NULL, entries, string, NULL, max_lg);
    }

  /* Create or update submenus */
  item = 0;
  i = 0;
  j = 0;
  ptritem = ptrmenu->ItemsList;
  while (j < entries)
    {
      if (string[i] == 'M')
        {
          /* it's a submenu: look for the corresponding entrie */
          while (item < ptrmenu->ItemsNb &&
                 (ptritem[item].ItemAction <= 0 ||
                  ptritem[item].ItemType != 'M' ||
                  /* skip empty menus */
                  (ptritem[item].ItemType == 'M' &&
                   !Prof_ShowSubMenu (ptritem[item].SubMenu))))
            item++;
          if (item < ptrmenu->ItemsNb)
            /* creation of the sub-menu */
            BuildSubMenu (ptritem[item].SubMenu, ref, j, frame, doc,
                          update, RO);
        }
      i = i + strlen (&string[i]) + 1;
      item++;
      j++;
    }
#endif /* _WX */
}

/*----------------------------------------------------------------------
  TteOpenMainWindow opens the application main window.
 
  Parameters:
  name: the name to be displayed as the title of the main window.
  ----------------------------------------------------------------------*/
void TteOpenMainWindow (char *name)
{
  /* Creation de la fenetre principale */
  UserErrorCode = 0;
  InitTranslations (name);
  /* no external action declared at that time */
  ActionList = NULL;
  TteLoadApplications ();
  
#ifdef _GTK
  if (TtDisplay == 0)
    {
      /* Connexion au serveur X impossible */
      TtaError (ERR_cannot_open_main_window);
      gtk_exit (1);
    }
  else
    {
      /* icone des fenetres de documents */
      wind_pixmap = TtaCreateBitmapLogo (logowindow_width, logowindow_height,
                                         (char *)logowindow_bits);
    }
#endif /* _GTK */
}



/*----------------------------------------------------------------------
  TtaAddTextZone

  Adds a new textual command in a document view.
  This function must specify a valid view of a valid document.
  Parameters:
  doc: the concerned document.
  view: the concerned view.
  label: label of the new entry.
  procedure: procedure to be executed when the new entry is changed by the
  user.
  listUrl gives URLs that will be displayed in the combobox.
  ----------------------------------------------------------------------*/
int TtaAddTextZone (Document doc, View view, char *label,
                    ThotBool editable, void (*procedure) (), 
                    char *listUrl)
{
  int            frame, ret;
  ThotWidget     w;
#ifdef _GTK
  ThotWidget     row;
  GList         *combo1_items = NULL;
  ThotWidget     combo;
  ThotWidget     ComboList;
#endif /* _GTK */
#ifdef _WINGUI
  RECT           rect;
  ThotWidget     wLabel;
#endif /* _WINGUI */

  UserErrorCode = 0;
  w = 0;
  ret = 0;
  /* verifie le parametre document */
  if (doc == 0 && view == 0)
    TtaError (ERR_invalid_parameter);
  else
    {
      frame = GetWindowNumber (doc, view);
      if (frame == 0 || frame > MAX_FRAME)
        TtaError (ERR_invalid_parameter);
#ifdef _WX
      else if (FrameTable[frame].WdFrame)
#else /* _WX */
        else if (FrameTable[frame].WdFrame && !FrameTable[frame].Text_Zone)
#endif /* _WX */
          {
#ifdef _WX
            TtaSetURLBar( frame, listUrl, procedure );
#endif /* _WX */

#ifdef _GTK
            row = FrameTable[frame].Row_Zone;
            /* row est de type GTK_HBOX */
            /*gtk_widget_hide (row->parent->parent);*/
            /* Insert a label for the entry text */	      
            if (label)
              {
                w = gtk_label_new (label);
                if (w->style->font == NULL ||
                    w->style->font->type != GDK_FONT_FONTSET)
                  w->style->font = DefaultFont;
                gtk_misc_set_alignment (GTK_MISC (w), 0.5, 0.5);
                gtk_box_pack_start (GTK_BOX (row), w, FALSE, TRUE, 5);
              }
            combo = gtk_combo_new ();
            gtk_combo_set_case_sensitive (GTK_COMBO (combo), TRUE);
            FrameTable[frame].Combo = combo;
            gtk_widget_ref (combo);
            /* Initialize combobox list */
            if (listUrl)
              /* list of URL in normal mode or list of Title in library mode */
              {
                combo1_items = InitComboBoxList (listUrl);
                /* Put created list into into combo */
                gtk_combo_set_popdown_strings (GTK_COMBO (combo), combo1_items);
                /* handle arrow key in combobox */
                gtk_combo_set_use_arrows_always (GTK_COMBO (combo), TRUE);
                /* Free memory */
                g_list_free (combo1_items);
              }
            w = GTK_COMBO (combo)->entry;
            ComboList = GTK_COMBO (combo)->list;
            gtk_combo_disable_activate (GTK_COMBO (combo)); 
            if (editable)
              {/* Normal combobox in Amaya */
                if (procedure)
                  {
                    /* execute APP_TextCallback GTK when pressing enter */
                    ConnectSignalGTK (GTK_OBJECT (w), "activate",
                                      GTK_SIGNAL_FUNC (APP_TextCallbackGTK),
                                      (gpointer)frame);
                    /*(combo)->popwin is the window appearing when dopping
                      the list...*/
                    gtk_object_set_data (GTK_OBJECT (GTK_COMBO (combo)->popwin), 
                                         "entry", 
                                         (gpointer) w);
                    ConnectSignalGTK (GTK_OBJECT (GTK_COMBO (combo)->popwin), 
                                      "hide",
                                      GTK_SIGNAL_FUNC (APP_PopWinSelect),
                                      (gpointer) frame);
                    ConnectSignalGTK (GTK_OBJECT (GTK_COMBO (combo)->popwin), 
                                      "show",
                                      GTK_SIGNAL_FUNC (APP_PopWinShow),
                                      (gpointer) frame);
                    gtk_signal_connect (GTK_OBJECT (GTK_COMBO (combo)->popwin), 
                                        "event",
                                        GTK_SIGNAL_FUNC (APP_ComboEscape),
                                        (gpointer) frame);
                    FrameTable[frame].Call_Text = (Proc) procedure;
                    gtk_widget_show_all (row);
                  }
                else
                  gtk_widget_show_all (row);
              } 
            else
              {/* Open SVG library in Amaya */
                /* Make the text zone non editable */
                gtk_list_set_selection_mode (GTK_LIST (ComboList), GTK_SELECTION_SINGLE);
                gtk_entry_set_editable (GTK_ENTRY (w), FALSE);
                /* GTK_WIDGET_UNSET_FLAGS(GTK_ENTRY(w), GTK_CAN_FOCUS); */
                if (procedure)
                  {
                    gtk_signal_connect (GTK_OBJECT (w), "changed",
                                        GTK_SIGNAL_FUNC (APP_TextCallbackGTK),
                                        (gpointer)frame);
                    FrameTable[frame].Call_Text = (Proc) procedure;
                    gtk_widget_show_all (row->parent->parent);
                  }
                else
                  gtk_widget_show_all (row->parent);
              }
            if (w->style->font == NULL ||
                w->style->font->type != GDK_FONT_FONTSET)
              w->style->font = DefaultFont;
            gtk_box_pack_start (GTK_BOX (row), combo, TRUE, TRUE, 20);
            FrameTable[frame].Text_Zone = w;
            gtk_widget_show (w);
            gtk_widget_show (combo);
            gtk_widget_show (row);
#endif /* _GTK */    

#ifdef _WINGUI
            currentFrame = frame;
            GetClientRect (FrMainRef [frame], &rect);
            /* get the default GUI font */
            wLabel = CreateWindow ("STATIC", label, WS_CHILD | WS_VISIBLE | SS_LEFT, 
                                   5, 8, 0, 30, FrMainRef[frame], (HMENU) 1,
                                   hInstance, NULL);
            FrameTable[frame].Label = wLabel;
            /* set the font of the window */
            WIN_SetDialogfont (wLabel);
            if (editable)
              {
                /* IDC_COMBO1,26,36,48,30,CBS_DROPDOWN | CBS_AUTOHSCROLL | 
                   CBS_SORT | WS_VSCROLL | WS_TABSTOP */
                /*w = CreateWindow ("COMBOBOX", "",
                  WS_CHILD | WS_VISIBLE | WS_BORDER | WS_TABSTOP | WS_VSCROLL |
                  CBS_AUTOHSCROLL | CBS_DROPDOWN | CBS_HASSTRINGS ,
                  0, 0, 0, 100, FrMainRef[frame], (HMENU) 2, hInstance, NULL);*/
                w = CreateWindow ("COMBOBOX", "",
                                  WS_CHILD | WS_VISIBLE | WS_TABSTOP | 
                                  CBS_AUTOHSCROLL | CBS_DROPDOWN | CBS_HASSTRINGS ,
                                  0, 0, 0, 300, FrMainRef[frame], (HMENU) 2, hInstance, NULL);
              }
            else
              {
                w = CreateWindow ("COMBOBOX", "",
                                  WS_CHILD | WS_VISIBLE | WS_BORDER | WS_TABSTOP | WS_VSCROLL |
                                  CBS_AUTOHSCROLL| CBS_DROPDOWN | CBS_HASSTRINGS,
                                  0, 0, 0, 300, FrMainRef[frame], (HMENU) 3, hInstance, NULL);
              }
            /* set the font of the window */
            WIN_SetDialogfont (w);
            FrameTable[frame].Text_Zone = w;
            FrameTable[frame].Call_Text = (Proc) procedure;
	  
            lpfnTextZoneWndProc = (WNDPROC) SetWindowLong (GetWindow (w, GW_CHILD),
                                                           GWL_WNDPROC, (DWORD) TextZoneProc);
            lpfnComboBoxWndProc = (WNDPROC) SetWindowLong (w, GWL_WNDPROC,
                                                           (DWORD) ComboBoxProc);
            PostMessage (FrMainRef[frame], WM_SIZE, 0, MAKELPARAM (rect.right, rect.bottom));
#endif /* _WINGUI */

            ret = 1;
          }
    }
  /* force la mise a jour de la fenetre */
  TtaHandlePendingEvents ();
  return ret;
}

/*----------------------------------------------------------------------
  TtaSetTextZone

  Sets the text in text-zone in a document view.
  This function must specify a valid view of a valid document.
  Parameters:
  doc: identifier of the document.
  view: identifier of the view.
  listUrl gives URLs that will be displayed in the combobox.
  ----------------------------------------------------------------------*/
void TtaSetTextZone (Document doc, View view, char *listUrl)
{
  int            frame;
#ifndef _WX
  ThotWidget     w;
#ifdef _GTK
  GList         *combo1_items = NULL;
  ThotWidget     combo;
#endif /* _GTK */
#endif /* _WX */	      

  UserErrorCode = 0;
  /* verifie le parametre document */
  if (doc == 0 && view == 0)
    TtaError (ERR_invalid_parameter);
  else if (listUrl)
    {
      frame = GetWindowNumber (doc, view);
      if (frame == 0 || frame > MAX_FRAME)
        TtaError (ERR_invalid_parameter);
      else if (FrameTable[frame].WdFrame)
        {
#ifdef _WX
          TtaSetURLBar( frame, listUrl, NULL );
#else /* _WX */
          w = FrameTable[frame].Text_Zone;
          if (w)
            {
#ifdef _WINGUI
              /* Initialize listbox linked to combobox */
              InitWdComboBoxList (w, listUrl);
#endif  /* _WINGUI */
#ifdef _GTK
              /* list of URL OR Title OF librarIES */
              combo =  FrameTable[frame].Combo;
              combo1_items = InitComboBoxList (listUrl);
              /* Put created list into into combo */
              gtk_combo_set_popdown_strings (GTK_COMBO (combo), combo1_items);
              /* handle arrow key in combobox */
              gtk_combo_set_use_arrows_always (GTK_COMBO (combo), TRUE);
              /* Free memory */
              g_list_free (combo1_items);
#endif /* _GTK */
            }
#endif /* _WX */	      
        }
    }
}


/*----------------------------------------------------------------------
  TtcSwitchCommands

  Shows or hides the commands part in a document view.
  This function must specify a valid view of a valid document.
  Parameters:
  doc: identifier of the document.
  view: identifier of the view.
  ----------------------------------------------------------------------*/
void TtcSwitchCommands (Document doc, View view)
{
#ifdef _WX
  wxASSERT_MSG(FALSE, _T("Unused function"));
#endif /* _WX */

#ifndef _WX
  int                 frame;
#ifdef _WINGUI
  int     nbZonesShown = 0;
  ThotBool itemChecked = FALSE;
  RECT    r;
#endif /* _WINGUI */
#ifdef _GTK
  ThotWidget          row;
#endif /* _GTK */

  UserErrorCode = 0;
  /* verifie le parametre document */
  if (doc == 0 && view == 0)
    TtaError (ERR_invalid_parameter);
  else
    {
      frame = GetWindowNumber (doc, view);
      if (frame == 0 || frame > MAX_FRAME)
        TtaError (ERR_invalid_parameter);
      else if (FrameTable[frame].WdFrame != 0)
        {
#ifdef _GTK 
          row = GTK_WIDGET (FrameTable[frame].Row_Zone)->parent;
          if (row != 0)
            {
              if (GTK_WIDGET_VISIBLE(row))
                gtk_widget_hide (row);
              else
                gtk_widget_show_all (row);

            }
#endif /* _GTK */
#ifdef _WINGUI
          if (FrameTable[frame].Text_Zone &&
              IsWindowVisible (FrameTable[frame].Text_Zone))
            {
              if (!itemChecked)
                {
                  hmenu = WIN_GetMenu (frame); 
                  CheckMenuItem (hmenu, menu_item, MF_BYCOMMAND | MF_UNCHECKED); 
                  itemChecked = TRUE;
                }
              ShowWindow (FrameTable[frame].Label, SW_HIDE);
              ShowWindow (FrameTable[frame].Text_Zone, SW_HIDE);
            }
          else
            {
              if (!itemChecked)
                {
                  hmenu = WIN_GetMenu (frame); 
                  CheckMenuItem (hmenu, menu_item, MF_BYCOMMAND | MF_CHECKED); 
                }
              ShowWindow (FrameTable[frame].Label, SW_SHOW);
              ShowWindow (FrameTable[frame].Text_Zone, SW_SHOW);
            }
          GetClientRect (FrMainRef[frame], &r);
          PostMessage (FrMainRef[frame], WM_SIZE, 0, MAKELPARAM (r.right, r.bottom));
#endif /* _WINGUI */	     
        }
    }
  /* force la mise a jour de la fenetre */
  TtaHandlePendingEvents ();
#endif /* _WX */
}


/*----------------------------------------------------------------------
  Evenement sur une frame document.                              
  ----------------------------------------------------------------------*/
void DrawingInput (int *w, int frame, int *infos)
{
}

#ifdef _GTK
/*-----------------------------------------------------------------------
  ConnectSignalGTK
  Function used by GTK version to attach the callback function to the
  good event and to attache the signal connect ID to the widget in order
  to disconnect it further.
  -------------------------------------------------------------------------*/
void ConnectSignalGTK (GtkObject *w, gchar *signal_name,
                       GtkSignalFunc callback, gpointer data)
{
  guint id;
  id = gtk_signal_connect (GTK_OBJECT(w), signal_name,
                           GTK_SIGNAL_FUNC(callback), data);
  gtk_object_set_data (GTK_OBJECT (w), signal_name, (gpointer)id);
}

/*-----------------------------------------------------------------------
  ConnectSignalAfterGTK
  Function used by GTK version to attach the callback function to the
  good event and to attache the signal connect ID to the widget in order
  to disconnect it further. The signal  handler will be called after all
  the other handlers.
  -------------------------------------------------------------------------*/
void ConnectSignalAfterGTK (GtkObject *w, gchar *signal_name,
                            GtkSignalFunc callback, gpointer data)
{
  guint id;
  id = gtk_signal_connect_after (GTK_OBJECT(w), signal_name,
                                 GTK_SIGNAL_FUNC(callback), data);
  gtk_object_set_data (GTK_OBJECT (w), signal_name, (gpointer)id);
}
/*-----------------------------------------------------------------------
  RemoveSignalGTK 
  Function used by GTK version to remove the callback function to the
  good event and to remove the signal connect ID to the widget that permits
  reconization of the signal
  -------------------------------------------------------------------------*/
void RemoveSignalGTK (GtkObject *w, gchar *signal_name)
{
  long int id;
  id = 0;
  id = (long int)gtk_object_get_data (GTK_OBJECT (w), signal_name);
  if (id)
    {
      gtk_signal_disconnect (GTK_OBJECT (w), id);
      gtk_object_remove_data (GTK_OBJECT (w), signal_name);
    }
}

/*-----------------------------------------------------------------------
  get_targets
  Signal handler invoked when user focus on drawing area 
  -------------------------------------------------------------------------*/
void get_targets (GtkWidget *widget, gpointer data)
{  

  if (FrameTable[ActiveFrame].WdFrame)
    {
      /* request by default a UTF-8 string */
      gtk_selection_convert (GTK_WIDGET (FrameTable[ActiveFrame].WdFrame), 
                             GDK_SELECTION_PRIMARY, 
                             Utf8_Type,  
                             GDK_CURRENT_TIME);
    }
}

/*-----------------------------------------------------------------------
  When user begins a new selection
  -------------------------------------------------------------------------*/
void gtk_claim_selection()
{
  if (FrameTable[ActiveFrame].WdFrame)
    /* but now we own the selection, so goodbye to the other app */
    gtk_selection_owner_set (GTK_WIDGET (FrameTable[ActiveFrame].WdFrame),
                             GDK_SELECTION_PRIMARY,
                             GDK_CURRENT_TIME); 
}

/*-----------------------------------------------------------------------
  selection_received
  Signal handler called when the selections owner 
  (another application) returns the data 
  -------------------------------------------------------------------------*/
void selection_received (GtkWidget *widget, GtkSelectionData *sel_data,
                         gpointer data)
{
  if (sel_data->length > 0)
    {
      /* if ClipboardLength is not zero, the last Xbuffer comes from Thot */
      if (Xbuffer /*&& ClipboardLength == 0*/)
        /* remove the old Xbuffer sent by the X server */
        TtcClearClipboard ();

      if (Xbuffer == NULL)
        {
          Xbuffer = (unsigned char*)TtaGetMemory ((sel_data->length + 1) * sizeof (unsigned char));
          strncpy ((char *)Xbuffer, (char *)sel_data->data, sel_data->length);
          Xbuffer[sel_data->length] = EOS;
        }
      if (sel_data->type != Utf8_Type)
        PasteXClipboard (Xbuffer, strlen((char *)Xbuffer), TtaGetDefaultCharset ());
      else
        PasteXClipboard (Xbuffer, strlen((char *)Xbuffer), UTF_8);
    }
  else if (sel_data->target == Utf8_Type)
    gtk_selection_convert (widget, 
                           GDK_SELECTION_PRIMARY, 
                           String_Type,  
                           GDK_CURRENT_TIME);
} 


/*-----------------------------------------------------------------------
  selection_clear
  Called when another application claims the selection 
  -------------------------------------------------------------------------*/
gint selection_clear (GtkWidget *widget, GdkEventSelection *event, gpointer data)
{
  TtcClearClipboard ();
  TtaClearViewSelections ();
  return TRUE;
}

/*-----------------------------------------------------------------------
  selection_handle
  Supplies the Xbuffer as the selection. 
  -------------------------------------------------------------------------*/
void selection_handle (GtkWidget        *widget,
                       GtkSelectionData *selection_data,
                       guint             info,
                       guint             time_stamp,
                       gpointer          data)
{
  unsigned char      *s;

  /* When we return a single string, it should not be null terminated.
     That will be done for us */
  if (Xbuffer)
    {
      if (info == 2)
        {
          s = TtaConvertMbsToByte (Xbuffer, TtaGetDefaultCharset ());
          gtk_selection_data_set (selection_data,
                                  String_Type,
                                  8, 
                                  s, 
                                  strlen ((char *)s));
        }
      else
        gtk_selection_data_set (selection_data,
                                Utf8_Type,
                                8, 
                                Xbuffer, 
                                strlen ((char *)Xbuffer));
    }
}

#endif /* _GTK */

/*----------------------------------------------------------------------
  BuildMenus builds or rebuilds frame menus.
  The parameter RO is TRUE when only ReadOnly functions are accepted
  ----------------------------------------------------------------------*/
void TtaUpdateMenus (Document doc, View view, ThotBool RO)
{
  Menu_Ctl           *ptrmenu, *ptrsmenu;
  Item_Ctl           *ptr, *sptr;
  int                 profile, action, i, j, m = 0;

  if (doc)
    {
#ifdef _WX
      ptrmenu = DocumentMenuList;
      profile = TtaGetDocumentProfile (doc);
      while (ptrmenu)
        {
          m++;
          /* skip menus that concern another view */
          if (ptrmenu->MenuID != 0 /* skip menu File */ &&
              !ptrmenu->MenuAttr &&
              !ptrmenu->MenuSelect &&
              !ptrmenu->MenuContext &&
              !ptrmenu->MenuDocContext &&
              !ptrmenu->MenuHelp &&
              (ptrmenu->MenuView == 0 || ptrmenu->MenuView == view) &&
              Prof_ShowMenu (ptrmenu))
            {
              ptr = ptrmenu->ItemsList;
              i = 0;
              while (i < ptrmenu->ItemsNb)
                {
                  action = ptr[i].ItemAction;
                  if (action == -1)
                    ;	/* separator */
                  else if (ptr[i].ItemType == 'M')
                    {
                      j = 0;
                      ptrsmenu = ptr[i].SubMenu;
                      sptr = ptrsmenu->ItemsList;
                      while (j < ptrsmenu->ItemsNb)
                        {
                          action = sptr[j].ItemAction;
                          if (action == -1)
                            ;	/* separator */
                          else if (Prof_BelongDoctype (MenuActionList[action].ActionName,
                                                       profile, RO))
                            MenuActionList[action].ActionActive[doc] = TRUE;
                          else
                            MenuActionList[action].ActionActive[doc] = FALSE;
                          j++;
                        }
                    }
                  else if (MenuActionList[action].ActionName == NULL ||
                           !strcmp (MenuActionList[action].ActionName, "TtcUndo") ||
                           !strcmp (MenuActionList[action].ActionName, "TtcRedo") ||
                           !strcmp (MenuActionList[action].ActionName, "StopTransfer"))
                    ; // don't change the current status
                  else if (Prof_BelongDoctype (MenuActionList[action].ActionName,
                                               profile, RO))
                    MenuActionList[action].ActionActive[doc] = TRUE;
                  else
                    MenuActionList[action].ActionActive[doc] = FALSE;
                  i++;
                }
              // refresh that menu
              TtaRefreshTopMenuStats (doc, m);
            }
          ptrmenu = ptrmenu->NextMenu;
        }
#endif /*_WX */
    }
}


/*----------------------------------------------------------------------
  MakeFrame
  Create a frame at position X,Y and dimensions width,height (if >0).
  - name gives the title of the window.
  - schema gives the schema name of the current document.
  - view is the schema view number.
  - doc gives the document index.
  - withMenu is TRUE when menus are displayed
  - withButton is TRUE when buttons are displayed
  Returns:
  - volume: the number of characters that can be displayed in the window.
  - the allocated window index or 0.
  ----------------------------------------------------------------------*/
int  MakeFrame (char *schema, int view, char *name, int X, int Y,
                int width, int height, int *volume, int doc,
                ThotBool withMenu, ThotBool withButton)
{
  /* this is for none gui compilation */
  return 0;
}

/*----------------------------------------------------------------------
  TtaDisableScrollbars  : Disable scrollbars for this view                 
  ----------------------------------------------------------------------*/
void TtaDisableScrollbars (Document doc, View view)
{
  int frame;

  frame = GetWindowNumber (doc, view);
  FrameTable[frame].WdScrollH = NULL;
  FrameTable[frame].WdScrollV = NULL;
#ifdef _GL
  FrameTable[frame].Scroll_enabled = FALSE;
#endif /* _GL */
}
/*----------------------------------------------------------------------
  Si l'entree existe :
  WX: detruit seulement la AmayaFrame correspondante ainsi que son canvas opengl (AmayaCanvas),
  mais ne detruit pas les menus car ils sont associes au document.                                             
  Ferme la fenetre, detruit le fichier et libere l'entree.      
  Libere toutes les boites allouees a la fenetre.
  ----------------------------------------------------------------------*/
void DestroyFrame (int frame)
{
  ThotFrame           w;
#ifndef _WX
  int                 i;
#endif /* _WX */
  
#ifdef _GL
  /* set the frame context active to avoid mesa warnings */
  GL_prepare (frame);
  GL_DestroyFrame (frame);
#endif /* _GL */
  
  CloseTextInsertion ();
#ifdef _GL
  /* free animate blocks */
  if (FrameTable[frame].Animated_Boxes)
    {
      FreeAnimatedBoxes ((Animated_Cell *)FrameTable[frame].Animated_Boxes);
      FrameTable[frame].Animated_Boxes = NULL;
    }
#endif /* _GL */

  w = FrameTable[frame].WdFrame;
  if (w != 0)
    {
      /* don't destroy frame menu on WX because menus are specific to the document */
#ifndef _WX
      Menu_Ctl           *ptrmenu;
      Item_Ctl           *ptr;
      int                 action;
      int                 ref, item;
      /* Destruction des menus attaches a la fenetre */
      ptrmenu = FrameTable[frame].FrMenus;
      i = 0;
      ref = frame + MAX_LocalMenu;	/* reference du menu construit */
      while (ptrmenu != NULL)
        {
          /* saute les menus qui ne concernent pas cette vue */
          if (ptrmenu->MenuView == 0 || ptrmenu->MenuView == FrameTable[frame].FrView)
            {
              FrameTable[frame].WdMenus[i] = 0;
              TtaDestroyDialogue (ref);
              item = 0;
              ptr = ptrmenu->ItemsList;
              while (item < ptrmenu->ItemsNb)
                {
                  action = ptr[item].ItemAction;
                  if (action != -1 && action < MaxMenuAction &&
                      (ptr[item].ItemType == 'B' || ptr[item].ItemType == 'T'))
                    /* Desactive l'action correspondante pour cette fenetre */
                    MenuActionList[action].ActionActive[frame] = FALSE;
                  item++;
                }
            }
          ptrmenu = ptrmenu->NextMenu;
          ref += MAX_ITEM;
          i++;
        }
#endif /* _WX */

#ifdef _GTK
      gtk_widget_destroy (GTK_WIDGET (gtk_widget_get_toplevel (GTK_WIDGET (FrameTable[frame].WdFrame))));
#endif /* _GTK */
#ifdef _WINGUI
      FrameTable[frame].Text_Zone = 0;
      if (hAccel[frame])
        {
          DestroyAcceleratorTable (hAccel[frame]);
          hAccel[frame] = NULL;
        }
#endif /* _WINGUI */

      /* with WX, never really delete the widgets */
      /* keep it alive in order to reuse it for the next frame */
#ifndef _WX
      FrRef[frame] = 0;
      FrameTable[frame].WdStatus = NULL;
      FrameTable[frame].WdFrame = 0;
#endif /* _WX */

      /* Elimine les evenements ButtonRelease, DestroyNotify, FocusOut */
      ClearConcreteImage (frame);
      ThotFreeFont (frame);	/* On libere les polices de caracteres utilisees */

#ifdef _WX
      TtaDetachFrame( frame );
      TtaDestroyFrame( frame );
      FrameTable[frame].WdFrame = 0;
#endif /* _WX */
    }
  FrameTable[frame].FrDoc = 0;
#ifdef _WINGUI
  /* clean the whole CatList of the frame */
  CleanFrameCatList (frame, 0);
  for (i = 0; i < MAX_BUTTON; i++)
    {
      TtaFreeMemory (FrameTable[frame].Button[i]);
      FrameTable[frame].Button[i] = 0;
      FrameTable[frame].ButtonId[i] = -1;
    }
  if (FrMainRef[frame])
    DestroyWindow (FrMainRef[frame]);
#endif /* _WINGUI */
#ifdef _GTK
  for (i = 0; i < MAX_BUTTON; i++)
    FrameTable[frame].Button[i] = 0;
#endif /* _GTK */
#ifdef _WX
  TtaHandlePendingEvents();
#endif /* _WX */
}


/*----------------------------------------------------------------------
  GetMenu_Ctl returns the pointer to the right menu context. 
  ----------------------------------------------------------------------*/
static Menu_Ctl *GetMenu_Ctl (int frame, int menu)
{  
  int                 i;
  Menu_Ctl           *ptrmenu;
#ifdef _WX
  ptrmenu = DocumentMenuList;
#else /* _WX */
  ptrmenu = FrameTable[frame].FrMenus;
#endif /* _WX */
  i = 0;
  while (i != menu && ptrmenu != NULL)
    {
      ptrmenu = ptrmenu->NextMenu;
      i++;
    }
  return (ptrmenu);
}


/*----------------------------------------------------------------------
  FindMenu returns the menu index and its context if this menu is
  displayed in this specific frame or -1.
  ----------------------------------------------------------------------*/
int FindMenu (int frame, int menuID, Menu_Ctl ** ctxmenu)
{
  Menu_Ctl           *ptrmenu;
  int                 m;

  /* Look for the menu */
  m = 1;			/* menu index */
  /* look for that menu in the menu list */
#ifdef _WX
  ptrmenu = DocumentMenuList;
#else /* _WX */
  ptrmenu = FrameTable[frame].FrMenus;
#endif /* _WX */      
  while (ptrmenu != NULL && menuID != ptrmenu->MenuID)
    {
      m++;
      ptrmenu = ptrmenu->NextMenu;
    }
   
  *ctxmenu = ptrmenu;
  if (ptrmenu == NULL)
    /* menu not found */
    return (-1);
  else if (ptrmenu->MenuView != 0 &&
           ptrmenu->MenuView != FrameTable[frame].FrView)
    /* menu found but that frame is not concerned */
    return (-1);
  else
    /* ok */
    return (m);
}


/*----------------------------------------------------------------------
  FindItemMenu returns all information concerning that dialogue entry
  in this specific frame:
  - menu index or -1
  - submenu index or 0
  - item index or 0
  - action index or -1
  ----------------------------------------------------------------------*/
static void FindItemMenu (int frame, int menuID, int itemID, int *menu,
                          int *submenu, int *item, int *action)
{
  Menu_Ctl           *ptrmenu, *ptrsmenu;
  Item_Ctl           *ptr;
  int                 i, j, max;
  int                 m, sm;
  int                 entry, sentry;             
  ThotBool            found;

  j = 0;
  i = 0;
  entry = 0;
  sm = 0;
  sentry = 0;
  /* look for that menu in the menu list */
  m = FindMenu (frame, menuID, &ptrmenu);
  found = (m != -1);
  if (found)
    {
      /* search that item in the item list or in submenus */
      ptr = ptrmenu->ItemsList;
      found = FALSE;
      max = ptrmenu->ItemsNb;
      ptrsmenu = NULL;
      while (ptrmenu && !found)
        {
          while (i < max && !found)
            {
              j = ptr[i].ItemAction;
              if (j == -1)
                {
                  i++;	/* separator */
                  entry++;
                }
              else if (ptr[i].ItemID == itemID)
                {
                  /* the entry is found */
                  found = TRUE;
                  if (ptr[i].ItemType == 'M')
                    /* it doesn't match an action */
                    j = -1;
                }
              else if (ptr[i].ItemType == 'M')
                {
                  if (ptr[i].SubMenu->ItemsNb == 0)
                    i++;
                  else
                    {
                      /* search in that submenu */
                      sm = i + 1;
                      sentry = entry + 1;
                      ptrsmenu = ptr[i].SubMenu;
                      i = 0;
                      entry = 0;
                      ptr = ptrsmenu->ItemsList;
                      max = ptrsmenu->ItemsNb;
                    }
                }
              else
                {
                  /* it's not that one */
                  i++;
                  entry++;
                }
            }
	   
          /* do we close the search in a submenu? */
          if (!found && ptrsmenu != NULL)
            {
              /* continue the search in the menu */
              i = sm;
              sm = 0;
              entry = sentry;
              sentry = 0;
              ptrsmenu = NULL;
              ptr = ptrmenu->ItemsList;
              max = ptrmenu->ItemsNb;
            }
          else
            /* we close the menu search and this itemID doesn't exist */
            ptrmenu = NULL;
        }
    }

  /* do we sucess? */
  if (found)
    {
      /* yes */
      *menu = m;
      *submenu = sm;
#ifdef _WINGUI
      *item = entry;
#endif /* _WINGUI */
#if defined(_GTK) || defined(_WX)
      *item = i;
#endif /* #if defined(_GTK) || defined(_WX) */
      *action = j;
    }
  else
    {
      /* no */
      *menu = -1;
      *submenu = 0;
      *item = 0;
      *action = -1;
    }
}

/*----------------------------------------------------------------------
  SwitchUndo enables (on=TRUE) or disables (on=FALSE) the Undo
  entry in all document frames.
  ----------------------------------------------------------------------*/
void SwitchUndo (PtrDocument pDoc, ThotBool on)
{  
#ifdef _WX
  if (pDoc == NULL)
    {
      for (int doc_id = 1; doc_id < MAX_DOCUMENTS; doc_id++)
        {
          pDoc = LoadedDocument[doc_id-1];
          if (pDoc)
            SwitchUndo(pDoc, on);
        }
    }
  else
    { 
      Document document  = IdentDocument(pDoc);
      int      window_id = TtaGetDocumentWindowId( document, -1 );

      /* do nothing if the document doesn't have a window parent */
      if ( window_id <= 0 )
        return;

      int      item_id   = WindowTable[window_id].MenuItemUndo;
      int      action    = FindMenuActionFromMenuItemID(NULL, item_id);
      
      if ( action > 0 &&
           action < MaxMenuAction &&
           MenuActionList[action].ActionActive[document] != on)
        {
          MenuActionList[action].ActionActive[document] = on;
          TtaRefreshMenuItemStats( document, NULL, item_id );
        }
    }
#endif /* _WX */

#ifndef _WX
  int               view, frame;
  int               ref, item;

  if (pDoc == NULL)
    return;
  for (view = 0; view < MAX_VIEW_DOC; view++)
    {
      if (pDoc->DocView[view].DvPSchemaView > 0)
        {
          frame = pDoc->DocViewFrame[view];
          if (frame != 0 && FrameTable[frame].MenuUndo != -1)
            {
              ref = FrameTable[frame].MenuUndo;
              item = FrameTable[frame].EntryUndo;
              if (on)
                TtaRedrawMenuEntry (ref, item, NULL, (ThotColor)-1, 1);
              else
                TtaRedrawMenuEntry (ref, item, NULL, InactiveB_Color, 0);
            }  
        }
    }
#endif /* _WX */
} 

/*----------------------------------------------------------------------
  SwitchRedo enables (on=TRUE) or disables (on=FALSE) the Redo
  entry in all document frames.
  ----------------------------------------------------------------------*/
void SwitchRedo (PtrDocument pDoc, ThotBool on)
{
#ifdef _WX
  if (pDoc == NULL)
    {
      for (int doc_id = 1; doc_id < MAX_DOCUMENTS; doc_id++)
        {
          pDoc = LoadedDocument[doc_id-1];
          if (pDoc)
            SwitchRedo(pDoc, on);
        }
    }
  else
    {
      Document document  = IdentDocument(pDoc);
      int      window_id = TtaGetDocumentWindowId( document, -1 );

      /* do nothing if the document doesn't have a window parent */
      if ( window_id <= 0 )
        return;

      int      item_id   = WindowTable[window_id].MenuItemRedo;
      int      action    = FindMenuActionFromMenuItemID(NULL, item_id);
      
      if ( action > 0 &&
           action < MaxMenuAction &&
           MenuActionList[action].ActionActive[document] != on)
        {
          MenuActionList[action].ActionActive[document] = on;
          TtaRefreshMenuItemStats( document, NULL, item_id );
        }
    }
#endif /* _WX */

#ifndef _WX
  int                 view, frame;
  int                 ref, item;

  if (pDoc == NULL)
    return;
  for (view = 0; view < MAX_VIEW_DOC; view++)
    {     
      if (pDoc->DocView[view].DvPSchemaView > 0)
        {
          frame = pDoc->DocViewFrame[view];
          if (frame != 0 && FrameTable[frame].MenuRedo != -1)
            {
              ref = FrameTable[frame].MenuRedo;
              item = FrameTable[frame].EntryRedo;
              if (on)
                TtaRedrawMenuEntry (ref, item, NULL, (ThotColor)-1, 1);
              else
                TtaRedrawMenuEntry (ref, item, NULL, InactiveB_Color, 0);
            }
        }
    }
#endif /* _WX */
}

/*----------------------------------------------------------------------
  SwitchPaste enables (on=TRUE) or disables (on=FALSE) the Paste
  entry in all frames.
  ----------------------------------------------------------------------*/
void SwitchPaste (PtrDocument pDoc, ThotBool on)
{
#ifdef _WX
  if (pDoc == NULL)
    {
      for (int doc_id = 1; doc_id < MAX_DOCUMENTS; doc_id++)
        {
          pDoc = LoadedDocument[doc_id-1];
          if (pDoc)
            SwitchPaste(pDoc, on);
        }
    }
  else
    {
      Document document  = IdentDocument(pDoc);
      int      window_id = TtaGetDocumentWindowId( document, -1 );

      /* do nothing if the document doesn't have a window parent */
      if ( window_id <= 0 )
        return;

      int      item_id   = WindowTable[window_id].MenuItemPaste;
      int      action    = FindMenuActionFromMenuItemID(NULL, item_id);
      
      if ( action > 0 &&
           action < MaxMenuAction &&
           MenuActionList[action].ActionActive[document] != on)
        {
          MenuActionList[action].ActionActive[document] = on;
          TtaRefreshMenuItemStats( document, NULL, item_id );
        }
    }
#endif /* _WX */

#ifndef _WX
  int                 frame;
  int                 ref, item;

  frame = 1;
  while (frame <= MAX_FRAME)
    {
      if (FrameTable[frame].WdFrame != 0 && FrameTable[frame].FrDoc != 0)
        {
          if (pDoc == NULL ||
              pDoc == LoadedDocument[FrameTable[frame].FrDoc - 1])
            {
              ref = FrameTable[frame].MenuPaste;
              item = FrameTable[frame].EntryPaste;
              if (ref != -1)
                {
                  if (on && !LoadedDocument[FrameTable[frame].FrDoc - 1]->DocReadOnly)
                    TtaRedrawMenuEntry (ref, item, NULL, (ThotColor)-1, 1);
                  else if (!on)
                    /* active the paste command */
                    TtaRedrawMenuEntry (ref, item, NULL, InactiveB_Color, 0);
                }
            }
        }
      frame++;
    }
#endif /* _WX */         
}

/*----------------------------------------------------------------------
  TtaEnableAction enable/disable the given action.
  ----------------------------------------------------------------------*/
void TtaEnableAction( Document document, const char * action_name, ThotBool enable )
{
#ifdef _WX
  int      action_id = FindMenuAction(action_name);
  int        item_id = FindMenuItemIDFromMenuAction(NULL, action_id);

  wxASSERT( action_id > 0 && action_id < MaxMenuAction );
  
  if ( action_id > 0 &&
       action_id < MaxMenuAction &&
       MenuActionList[action_id].ActionActive[document] != enable)
    {
      MenuActionList[action_id].ActionActive[document] = enable;
      TtaRefreshMenuItemStats( document, NULL, item_id );
    }    
#endif /* _WX */
}

/*----------------------------------------------------------------------
  TtaSetMenuOff desactive le menu (1 a n) de la vue du document ou   
  de la fenetre principale (document = 0, view = 0).                 
  ----------------------------------------------------------------------*/
void TtaSetMenuOff (Document document, View view, int menuID)
{
  int                 menu;
  int                 frame;
#ifdef _WX
  PtrDocument         pDoc = LoadedDocument[document-1];
#endif /* _WX */
  Menu_Ctl*           ptrmenu;
  
  if (document == 0 || view == 0)
    frame = 0;
  else
    frame = GetWindowNumber (document, view);
  
  /* Check parameters */
  if (frame > MAX_FRAME)
    return;
  else if ((FrameTable[frame].WdFrame) == 0)
    return;
  
  menu = FindMenu (frame, menuID, &ptrmenu);
  if (menu != -1)
    {
      menu--;
#ifdef _WX
      if (pDoc->EnabledMenus[menu])
        {
          pDoc->EnabledMenus[menu] = FALSE;
          TtaRefreshTopMenuStats( document, menu );
        }
#endif /* _WX */
      
#ifndef _WX
#ifdef _GTK
      if (FrameTable[frame].EnabledMenus[menu])
#endif /* _GTK */
        {
          /* Get the button widget */
          ThotMenu            w;
          int                 ref;
          w = FrameTable[frame].WdMenus[menu];
          if (w != 0)
            {
              FrameTable[frame].EnabledMenus[menu] = FALSE;
              ref = (menu * MAX_ITEM) + frame + MAX_LocalMenu;
              /* Disable */
#ifdef _WINGUI
              WIN_TtaSetPulldownOff (ref, w, TtaGetViewFrame (document, view));
#endif /* _WINGUI */
#ifdef _GTK
              TtaSetPulldownOff (ref, w);
              TtaSetPulldownOff (ref, w);
              /* Set the button inactive */
              gtk_widget_set_sensitive (GTK_WIDGET(w), FALSE);
#endif /* _GTK */
            }
        }
#endif /* _WX */
    }	  
}

/*----------------------------------------------------------------------
  TtaSetMenuOn reactive le menu (1 a n) de la vue du document ou     
  de la fenetre principale (document = 0, view = 0).                 
  ----------------------------------------------------------------------*/
void TtaSetMenuOn (Document document, View view, int menuID)
{
  int                 menu;
  int                 frame;
#ifdef _WX
  PtrDocument         pDoc = LoadedDocument[document-1];  
#endif /* _WX */
  Menu_Ctl*           ptrmenu;

  if (document == 0 || view == 0)
    frame = 0;
  else
    frame = GetWindowNumber (document, view);
  
  /* Check parameters */
  if (frame > MAX_FRAME)
    return;
  else if ((FrameTable[frame].WdFrame) == 0)
    return;
  menu = FindMenu (frame, menuID, &ptrmenu);
  if (menu != -1)
    {
      menu--;
      
#ifdef _WX
      if (!pDoc->EnabledMenus[menu])
        {
          pDoc->EnabledMenus[menu] = TRUE;
          TtaRefreshTopMenuStats( document, menu );
        }
#endif /* _WX */
      
#ifndef _WX
#ifdef _GTK
      if (!FrameTable[frame].EnabledMenus[menu])
#endif /* _GTK */
        {
          /* Get the button widget */
          ThotMenu            w;
          int                 ref;
          w = FrameTable[frame].WdMenus[menu];
          if (w != 0)
            {
              FrameTable[frame].EnabledMenus[menu] = TRUE;
              ref = (menu * MAX_ITEM) + frame + MAX_LocalMenu;
              /* Enaable */
#ifdef _WINGUI
              WIN_TtaSetPulldownOn (ref, w, TtaGetViewFrame (document, view));
#endif /* _WINGUI */
#ifdef _GTK
              TtaSetPulldownOn (ref, w);
              gtk_widget_set_sensitive (GTK_WIDGET(w), TRUE);
#endif /* _GTK */
            }  	  
        }
#endif /* _WX */
    }
}


/*----------------------------------------------------------------------
  TtaSetToggleItem positionne l'item du menu de la vue du document   
  ou de la fenetre principale (document = 0, view = 0).   
  ----------------------------------------------------------------------*/
void TtaSetToggleItem (Document document, View view, int menuID, int itemID, ThotBool on)
{
  int                 frame;
  int                 menu, submenu;
  int                 item, action;

  /* Check parameters */
  if (menuID == 0 || itemID == 0)
    return;
  if (document == 0 || view == 0)
    frame = 0;
  else
    frame = GetWindowNumber (document, view);

  if (frame > MAX_FRAME)
    return;
  else if ((FrameTable[frame].WdFrame) == 0)
    return;

  /* Search the menu, submenu and item */
  FindItemMenu (frame, menuID, itemID, &menu, &submenu, &item, &action);
  if (menu >= 0 && item >= 0)
    {
#ifdef _WX
      menu--;
      if ( action != -1 && MenuActionList[action].ActionToggle[document] != on )
        MenuActionList[action].ActionToggle[document] = on;
      /* refresh the item even if the action state didn't change because when clicking on the menu item
       * the WX toolkit will performe a toggle action and update automaticaly the menu item so
       * to be sure just force the refresh */
      TtaRefreshMenuItemStats( document, NULL, itemID );
#else /* _WX */
      int                 ref;
      /* entry found */
      ref = ((menu - 1) * MAX_ITEM) + frame + MAX_LocalMenu;
      if (submenu != 0)
        ref += submenu * MAX_MENU * MAX_ITEM;
      /* enable the entry */
#ifdef _WINGUI
      WIN_TtaSetToggleMenu (ref, item, on, FrMainRef[frame]);
#endif /* _WINGUI */
#if defined(_GTK)
      TtaSetToggleMenu (ref, item, on);
#endif /* #if defined(_GTK) */
#endif /* _WX */
    }
}


/*----------------------------------------------------------------------
  TtaSetItemOff desactive l'item actionName de la vue du document  
  ou de la fenetre principale (document = 0, view = 0).   
  ----------------------------------------------------------------------*/
void  TtaSetItemOff (Document document, View view, int menuID, int itemID)
{
  int                 frame;
  int                 menu, submenu;
  int                 item;
  int                 action;
#ifndef _WX
  int                 ref;
#endif /* _WX */

  /* Check parameters */
  if (document == 0 || view == 0)
    frame = 0;
  else
    frame = GetWindowNumber (document, view);
   
  if (frame > MAX_FRAME)
    return;
  else if ((FrameTable[frame].WdFrame) == 0)
    return;
  /* Search the menu, submenu and item */
  FindItemMenu (frame, menuID, itemID, &menu, &submenu, &item, &action);
#ifdef _WX
  if (action > 0 && action < MaxMenuAction &&
      MenuActionList[action].ActionActive[document])
    /* the entry is found and is active */
    MenuActionList[action].ActionActive[document] = FALSE;
  if (menu > 0)
    TtaRefreshMenuItemStats( document, NULL, itemID );
#else /* _WX */
  if (action > 0 && action < MaxMenuAction &&
      MenuActionList[action].ActionActive[frame])
    /* the entry is found and is active */
    MenuActionList[action].ActionActive[frame] = FALSE;
  if (menu > 0)
    {
      ref = ((menu - 1) * MAX_ITEM) + frame + MAX_LocalMenu;
      if (submenu != 0)
        ref += submenu * MAX_MENU * MAX_ITEM;
      /* enable the entry */
      TtaRedrawMenuEntry (ref, item, NULL, InactiveB_Color, 0);
    }
#endif /* _WX */
}


/*----------------------------------------------------------------------
  TtaSetItemOn active l'item actionName de la vue du document      
  ou de la fenetre principale (document = 0, view = 0).   
  ----------------------------------------------------------------------*/
void  TtaSetItemOn (Document document, View view, int menuID, int itemID)
{
  int                 frame;
  int                 menu, submenu;
  int                 item;
  int                 action;
#ifndef _WX
  int                 ref;
#endif /* _WX */

  /* Si les parametres sont invalides */
  if (document == 0 || view == 0)
    frame = 0;
  else
    frame = GetWindowNumber (document, view);
  if (frame > MAX_FRAME)
    return;
  else if ((FrameTable[frame].WdFrame) == 0)
    return;
  /* Recherche les bons indices de menu, sous-menu et item */
  FindItemMenu (frame, menuID, itemID, &menu, &submenu, &item, &action);
#ifdef _WX
  if (action > 0 && action < MaxMenuAction &&
      !MenuActionList[action].ActionActive[document])
    {
      /* the entry is found and is not active */
      MenuActionList[action].ActionActive[document] = TRUE;
      TtaRefreshMenuItemStats( document, NULL, itemID );
    }
#endif /* _WX */

#ifndef _WX
  if (action > 0 && action < MaxMenuAction &&
      !MenuActionList[action].ActionActive[frame])
    /* the entry is found and is not active */
    MenuActionList[action].ActionActive[frame] = TRUE;
  if (menu > 0)
    {
      PtrDocument         pDoc;
      /* enable the menu entry */
      ref = ((menu - 1) * MAX_ITEM) + frame + MAX_LocalMenu;
      if (submenu != 0)
        ref += submenu * MAX_MENU * MAX_ITEM;
       
      pDoc = LoadedDocument [document - 1];
      if (ref == FrameTable[frame].MenuRedo &&
          item == FrameTable[frame].EntryRedo &&
          (pDoc->DocReadOnly || pDoc->DocNbUndone == 0))
        return;
      else if (ref == FrameTable[frame].MenuUndo &&
               item == FrameTable[frame].EntryUndo &&
               (pDoc->DocReadOnly || pDoc->DocNbEditsInHistory == 0))
        return;
      else if (ref == FrameTable[frame].MenuPaste &&
               item == FrameTable[frame].EntryPaste &&
               (pDoc->DocReadOnly ||
                (FirstSavedElement == NULL && ClipboardThot.BuLength == 0)))
        return;
      TtaRedrawMenuEntry (ref, item, NULL, (ThotColor)-1, 1);
    }
#endif /* _WX */

}


/*----------------------------------------------------------------------
  TtaSetCallback

  Specifies the procedure that is called when the user activates a set of forms
  and/or menus created by the application.
  The parameter set gives the number of forms and/or menus created by the 
  application managed by this porcedure.
  This function must be called before processing any event, only if the
  application uses the Dialogue tool kit for generating specific forms or menus.
  This function replaces the DefineCallback function in the Dialogue tool kit.
  This procedure is called with three parameters: the menu or form reference,
  data type, and data value.

  void callbakProcedure(reference, datatype, data)
  int reference;
  int datatype;
  char *data; 

  Parameter:
  callbakProcedure: the application callback procedure.
  set: the number of forms and/or menus managed.
  Return:
  reference of the first form or menu.
  ----------------------------------------------------------------------*/
int TtaSetCallback (void (*callbakProcedure) (), int set)
{
  PtrCallbackCTX      ctxCallback;

  UserErrorCode = 0;
  if (FirstCallbackAPI == NULL)
    {
      /* le premier bloc de callback */
      FirstCallbackAPI = (PtrCallbackCTX) TtaGetMemory (sizeof (CallbackCTX));
      ctxCallback = FirstCallbackAPI;
    }
  else
    {
      ctxCallback = FirstCallbackAPI;
      while (ctxCallback->callbackNext != NULL)
        ctxCallback = ctxCallback->callbackNext;
      ctxCallback->callbackNext = (PtrCallbackCTX) TtaGetMemory (sizeof (CallbackCTX));
      ctxCallback = ctxCallback->callbackNext;
    }

  ctxCallback->callbackProc = callbakProcedure;
  ctxCallback->callbackSet = set;
  ctxCallback->callbackNext = NULL;
  return (TtaGetReferencesBase (set));
}


/*----------------------------------------------------------------------
  ThotCallback ge`re tous les retours du dialogue de Thot.        
  ----------------------------------------------------------------------*/
void ThotCallback (int ref, int typedata, char *data)
{
  Document            document;
  View                view;
  PtrCallbackCTX      ctxCallback;
  Menu_Ctl           *ptrmenu;
  int                 frame, item;
  int                 menu, base;
  int                 menuThot;
  int                 action, i, j;

  /* Termine l'insertion courante s'il y en a une */
#ifdef _WINGUI
  menu_item = ref + (int) data;
#endif /* _WINGUI */
  CloseTextInsertion ();

  if (ref >= MAX_ThotMenu)
    {
      if (FirstCallbackAPI == NULL)
        return;		/* pas de callback definis */
      else
        {
          /* recherche le bon callback */
          ctxCallback = FirstCallbackAPI;
          base = MAX_ThotMenu;
          while (ref >= base + ctxCallback->callbackSet)
            {
              if (ctxCallback->callbackNext == NULL)
                return;
              else
                {
                  base = base + ctxCallback->callbackSet;
                  ctxCallback = ctxCallback->callbackNext;
                }
            }
          (*(Proc3)ctxCallback->callbackProc) ((void *)ref, (void *)typedata, (void *)data);
        }
    }
  else if (ref < MAX_LocalMenu)
    /*** Action interne et optionnelle de l''eur ***/
    switch (ref)
      {
      case NumMenuInsert:
        (*(Proc3)ThotLocalActions[T_rcinsertpaste]) (
                                                     (void *)TRUE,
                                                     (void *)FALSE,
                                                     (void *)((long int) data + 1) );
        break;
      case NumMenuPaste:
        (*(Proc3)ThotLocalActions[T_rcinsertpaste]) (
                                                     (void *)FALSE,
                                                     (void *)TRUE,
                                                     (void *)((long int) data + 1));
        break;
      case NumMenuInclude:
        (*(Proc3)ThotLocalActions[T_rcinsertpaste]) (
                                                     (void *)FALSE,
                                                     (void *)FALSE,
                                                     (void *)((long int) data + 1));
        break;
      case NumMenuElChoice:
        (*(Proc2)ThotLocalActions[T_rchoice]) (
                                               (void *)((long int) data + 1),
                                               (void *)NULL);
        break;
      case NumSelectNatureName:
        (*(Proc2)ThotLocalActions[T_rchoice]) (
                                               (void *)0,
                                               (void *)data);
        break;
	
      case NumMenuAttrRequired:
      case NumMenuAttrNumNeeded:
      case NumMenuAttrTextNeeded:
      case NumMenuAttrEnumNeeded:
        (*(Proc3)ThotLocalActions[T_rattrreq]) (
                                                (void *)ref,
                                                (void *)((long int) data),
                                                (void *)data);
        break;
      case NumMenuAttr:
      case NumMenuAttrNumber:
      case NumMenuAttrText:
      case NumMenuAttrEnum:
        (*(Proc3)ThotLocalActions[T_rattrval]) (
                                                (void *)ref,
                                                (void *)((long int) data),
                                                (void *)data);
        break;
	
      case NumSelectLanguage:
        (*(Proc3)ThotLocalActions[T_rattrlang]) (
                                                 (void *)ref,
                                                 (void *)0,
                                                 (void *)data);
        break;
      case NumFormLanguage:
      case NumMenuAlphaLanguage:
        (*(Proc3)ThotLocalActions[T_rattrlang]) (
                                                 (void *)ref,
                                                 (void *)((long int) data),
                                                 (void *)NULL);
        break;
      case NumFormClose:
        (*(Proc3)ThotLocalActions[T_rconfirmclose]) (
                                                     (void *)ref,
                                                     (void *)typedata,
                                                     (void *)data);
        break;
	
      case NumFormPresChar:
      case NumFormPresFormat:
      case NumFormPresGraphics:
      case NumFormColors:
      case NumMenuCharFamily:
      case NumMenuCharFontStyle:
      case NumMenuCharFontWeight:
      case NumMenuCharFontSize:
      case NumMenuUnderlineType:
      case NumMenuUnderlineWeight:
      case NumMenuAlignment:
      case NumZoneRecess:
      case NumMenuRecessSense:
      case NumZoneLineSpacing:
      case NumMenuLineSpacing:
      case NumMenuStrokeStyle:
      case NumZoneStrokeWeight:
      case NumToggleWidthUnchanged:
      case NumTogglePatternUnchanged:
        (*(Proc3)ThotLocalActions[T_present]) (
                                               (void *)ref,
                                               (void *)(long int) data,
                                               (void *)NULL);
        break;
      case NumSelectPattern:
      case NumSelectForegroundColor:
      case NumSelectBackgroundColor:
        (*(Proc3)ThotLocalActions[T_present]) (
                                               (void *)ref,
                                               (void *)0,
                                               (void *)data);
        break;
      case NumFormPresentStandard:
      case NumMenuPresentStandard:
        (*(Proc2)ThotLocalActions[T_presentstd]) (
                                                  (void *)ref,
                                                  (void *)((long int) data));
        break;
      case NumFormSearchText:
      case NumMenuReplaceMode:
      case NumToggleUpperEqualLower:
      case NumMenuSearchNature:
        /* sous-menu mode de remplacement */
        (*(Proc3)ThotLocalActions[T_searchtext]) (
                                                  (void *)ref,
                                                  (void *)((long int) data),
                                                  (void *)NULL);
        break;
      case NumZoneTextSearch:
      case NumZoneTextReplace:
      case NumSelTypeToSearch:
      case NumSelAttributeToSearch:
        /* zone de saisie du texte de remplacement */
        (*(Proc3)ThotLocalActions[T_searchtext]) (
                                                  (void *)ref,
                                                  (void *)0,
                                                  (void *)data);
        break;
      case NumMenuOrSearchText:
        (*(Proc2)ThotLocalActions[T_locatesearch]) (
                                                    (void *)ref,
                                                    (void *)((long int) data));
        break;  
      case NumFormElemToBeCreated:
        CallbackElemToBeCreated (ref, (long int)data, NULL);
        break;
      case NumSelectElemToBeCreated:
        CallbackElemToBeCreated (ref, 0, data);
        break;

      default:
        if (ref >= NumMenuAttrName && ref <= NumMenuAttrName + MAX_ITEM)
          /* retour du menu des attributs */
          {
#if defined(_GTK)
            TtaSetDialoguePosition ();
#endif /* #if defined(_GTK) */
            (*(Proc3)ThotLocalActions[T_rattr]) (
                                                 (void *)ref,
                                                 (void *)((long int) data),
                                                 (void *)ActiveFrame);
          }
        break;
      }
  else
    {
      /*** Action attachee au retour du dialoque de l'application ***/
      /* Calcule les indices menu, item et frame */
      /* ref = (((item+1) * MAX_MENU + menu) * MAX_ITEM) + frame + MAX_LocalMenu */
      j = ref - MAX_LocalMenu;
      i = j / MAX_ITEM;
      frame = j - (i * MAX_ITEM);	/* reste de la division */
      item = i / MAX_MENU;
      menu = i - (item * MAX_MENU);	/* reste de la division */
      if (frame == 0)
        {
          document = 0;
          view = 0;
        }
      else
        {
          FrameToView (frame, &document, &view);
          if (document == 0)
            return;
#ifdef _WX
          int         window_id = TtaGetDocumentWindowId( document, -1 );
          menuThot = FindMenu (frame, WindowTable[window_id].MenuAttr, &ptrmenu) - 1;
#else /* _WX */
          menuThot = FindMenu (frame, FrameTable[frame].MenuAttr, &ptrmenu) - 1;
#endif /* _WX */
          if (menu == menuThot)
            {
              /* traitement du menu attribut */
#if defined(_GTK)
              TtaSetDialoguePosition ();
#endif /* #if defined(_GTK) */
              (*(Proc3)ThotLocalActions[T_rattr]) (
                                                   (void *)ref,
                                                   (void *)((long int) data),
                                                   (void *)frame);
              return;
            }
#ifdef _WX
          menuThot = FindMenu (frame, WindowTable[window_id].MenuSelect, &ptrmenu) - 1;
#else /* _WX */      
          menuThot = FindMenu (frame, FrameTable[frame].MenuSelect, &ptrmenu) - 1;
#endif /* _WX */
          if (menu == menuThot)
            {
              /* traitement du menu selection */
#if defined(_GTK)
              TtaSetDialoguePosition ();
#endif /* #if defined(_GTK) */
              (*(Proc3)ThotLocalActions[T_rselect]) ((void *)ref,
                                                     (void *)((long int) data + 1),
                                                     (void *)frame);
              return;
            }
        }

      /* Call the right action */
      ptrmenu = GetMenu_Ctl (frame, menu);
      action = 0;
      if (ptrmenu)
        {
          if (item != 0)
            {
              item--;
              if (item < ptrmenu->ItemsNb && ptrmenu->ItemsList)
                {
                  for (i = 0; i <= item; i++)
                    {
                      action = ptrmenu->ItemsList[i].ItemAction;
                      if (ptrmenu->ItemsList[i].ItemType == 'M' &&
                          ptrmenu->ItemsList[i].SubMenu->ItemsNb == 0)
                        item++;
                    }
                  ptrmenu = ptrmenu->ItemsList[item].SubMenu;
                }
            }
        }

      if (ptrmenu)
        {
          item = (long int) data;
          if (item < ptrmenu->ItemsNb && ptrmenu->ItemsList != NULL)
            {
              for (i = 0; i <= item; i++)
                {
                  action = ptrmenu->ItemsList[i].ItemAction;
                  if (ptrmenu->ItemsList[i].ItemType == 'M' &&
                      ptrmenu->ItemsList[i].SubMenu->ItemsNb == 0)
                    item++;
                }
            }
          /*action = GetActionItem(frame, menu, (int)data); */
          if (action > 0 && action < MaxMenuAction)
            /* l'action existe et le menu est actif */
#ifdef _WX
            if (MenuActionList[action].ActionActive[document])
#else /* _WX */
              if (MenuActionList[action].ActionActive[frame])
#endif /* _WX */
                {
                  if (MenuActionList[action].Call_Action)
                    (*(Proc2)MenuActionList[action].Call_Action) ((void *)document, (void *)view);
                }
        }
    }
  
#ifdef _WX
  // to be sure the focus is not lost
  TtaCheckLostFocus();
#endif /* _WX */
}
