#!/usr/bin/perl -w
package Forcer;

use strict;
use XML::Parser;
use Unicode::String qw(utf8 latin1);
	#to indicate that all string will be in utf8 (as they are read) by default
	#	Unicode::String->stringify_as( utf8 );





BEGIN {
	use vars qw( @ISA @EXPORT );
	use Exporter;

	@ISA = ('Exporter');# AutoLoader;

# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.
	@EXPORT = 	qw(
						&forcer
						);
}



my $out_put_dir;
my $char_into_control; #used in sub init_the_base as a boolean
my $OK_for_copy ; #used in sub search_and_recopy_a_label as a boolean 
my $found ; #used in sub search_and_recopy_a_label as a boolean 
my $label_searched ; #used in sub search_and_recopy_a_label to store the label actualy search 
#---------------end of global variables

################
## 						sub main
# this is a small tool to permit that the base will stay conform with the ".h "
# generated by the "EDITOR.A" . It is just a need of reorganization (in general)
# it read the ".h" and as it is specifie in it recopy all the text 
# between <label specific> and </label> from the
# old base on the new and indicate if any lakes occurs
################
sub forcer {
my $base_repertory = shift ; #"/home/ehuck/xmldoc/";
my $name_of_base = shift ;#"base_am_msg.xml";
my $base = $base_repertory . $name_of_base ;

my $h_file_repertory = shift ;#"/home/ehuck/xmldoc/";#"/home/ehuck/opera/Amaya/LINUX-ELF/amaya/";
my $name_of_h_file = shift ; #"amayamsg.h";#"EDITOR.h";
my $h_file = $h_file_repertory . $name_of_h_file ;

   $out_put_dir = shift;

my $line ;
my $define;
my $ref_name;
my $value;
my @rest;
my $i;

#---------------end of main variables


#	create the new base it in order to add at the end and write the begin of the new base 
	init_the_base ($base, $out_put_dir . $name_of_base ) ;	# create $base.NEW

#	read the ".h" file taken as reference line to line
	unless ( -r $h_file ) {
		print "fichier $h_file introuvable";
	} else {
		open ( IN, "<$h_file" ) || die "can't read $h_file because: $! \n";
	}
	
	while ($line = <IN> ) {
	
		chomp ( $line );
		if ( $line =~ /^#define/ ) {
			($define, $ref_name, $value, @rest) = split (/\s+/, $line);
			if (  $ref_name eq "TEXT_UNIT"
				&&	$ref_name eq "GRAPHICS_UNIT"
				&&	$ref_name eq "SYMBOL_UNIT"
				&&	$ref_name eq "PICTURE_UNIT"
				&&	$ref_name eq "REFERENCE_UNIT"
				&&	$ref_name eq "PAGE_BREAK"
				) {
				# don't do anything, it's normal basic types defined
			}
			elsif ( $value =~ /^\d/ ) {
#	recopy from the old base what necessary if it's possible, and treat the lakes
				unless (search_and_recopy_a_label ( $base,$ref_name )) { #if nothing's found 
					print "the label $ref_name never exist befor, it don't have a translate yet\n";
					print OUT "<label define=\"$ref_name\"></label>\n";				
				}
			}
			else { # it's a pb 
				print "probleme with line $i of $h_file\n";
			}
		} # else it's a commentary
	}



#	close the ".h" file 
	close ( IN ) ;
#	Ends the new base and close it
	end_the_base () ;	
# 	rename the new base with the name of the old, this one being store to ".old"
  


	print "\t\tEnd of reformationconf\n";

}################
## end main
################
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
sub init_the_base {
#	Create the new base and close it (to erase an a hipotetic already existing file )
	open ( OUT, ">".$_[1] . ".new") || die "can't create " . $_[1] . ".new because: $! \n";
	close ( OUT) || die "can't close ".$_[1].".new because: $! \n";
	
	open ( OUT , ">>" . $_[1] . ".new" ) || die "can't open for adds in " . $_[1] . "because: $! \n";
# all the rest is for recopy the begining of the base, and increment the version
 	$char_into_control = 0 ;

my $parser = new XML::Parser (
										ErrorContext  => 0 ,
										NoExpand	=> 1  
             						);
#	declaration of the subs used when events are noted	
$parser->setHandlers(
							Start => \&start ,
			   			End   => \&end ,
			   			Char => \&char ,
			   			Default => \&default
						);
open ( BASE ,"<". $_[0] ) || die "problem with the opening of the ".$_[0]." because of $! \n";
$parser->parse (*BASE); 
close ( BASE );

}
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
sub start {
	my $p = shift;
	my $element = shift ;
	if ( $element eq "base_message" 
		|| $element eq "control" 
		|| $element eq "language" 
		|| $element eq "messages") { 
		# 	store the attributes and their value	
 		my $attribute = shift;
		my %attributes ;
		while (defined $attribute ) {		
			$attributes { $attribute } = shift ;
			$attribute = shift;
		}
		if ( $element eq "base_message"  ) {
			if ( defined( $attributes{"version"}) ) {
				$attributes{"version"} += 1;
				print OUT "<$element"; 
				foreach $attribute ( keys( %attributes)) {
					print OUT " $attribute=\"" . $attributes{$attribute} . "\"";
				}
				print OUT ">\n";
 			}			
		}
		elsif ( $element eq "messages" ) {
			print OUT "<$element>\n"; # no parameters for this element
			# to abort the parsing = go to the last label named AMAYA_MSG_MAX
			$p->finish;
		}
		elsif ($element eq "control" ) { 
			$char_into_control = 1 ;
			print OUT "<$element>\n";  # no parameters for this element
		}
		elsif ($element eq "language" ) { 
			print OUT "\t<$element";
			foreach $attribute ( keys( %attributes)) {
					print OUT " $attribute=\"" . $attributes{$attribute} . "\"";
			}
			print OUT ">";
		}
	}	

}
#-------------------------------------------------------------------------------
sub end {
	if ($char_into_control) {
		my $p = shift;
		my $end_tag = shift;
		
		if ($end_tag eq "language") {
			print OUT "</$end_tag>\n";
		}
		elsif ($end_tag eq "control") {
			print OUT "</$end_tag>\n";
			$char_into_control = 0 ;
		}
	}
}
#-------------------------------------------------------------------------------
sub char {
	if ($char_into_control) {
		my $p = shift;
		my $data = shift;
		
		$data =~ s/\s+//;
		if ( $data ne "") {
			print OUT $data ;
		}
	}
}
#-------------------------------------------------------------------------------
sub default {	#for all the cases of an invalid xml document
	my ( $p, $data ) = @_;

	if ( $data =~ /^<\?xml/ ) { 	# it' the head
		print OUT "$data\n";	
	}

} #End default
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
###############################################################################

sub end_the_base {
	print OUT "</messages>\n</base_message>";
	close ( OUT ) || die "can't close the new base\n";
}

###############################################################################
sub search_and_recopy_a_label { #return if it's OK or not
	my $base = shift;
	$label_searched = shift ;
 	$found = 0 ;
	$OK_for_copy = 0 ;
	
# declaration of the parser
	my $parser = new XML::Parser (
											ErrorContext  => 0 ,
											NoExpand	=> 1  
             							);
#	declaration of the subs used when events are noted	
	$parser->setHandlers(
								Start => \&start_hndl ,
			   				End   => \&end_hndl ,
			   				Char => \&char_hndl ,
			   				Default => \&default_hndl
							);
	open ( BASE ,"<$base") || die "problem with the opening of the $base because of $! \n";
	$parser->parse (*BASE); 
	close ( BASE );
	return $found ;	
} #	End search_and_recopy_a_label

#-------------------------------------------------------------------------------
sub start_hndl {
	my $expat = shift; 
	my $element = shift; 	# element is the name of the tag
	my %attributes ;	#	to store the attributes
	my $attribute;
	
	if ( $element eq "label" || $OK_for_copy ) { 
		# 	store the attributes and their value	
 		$attribute = shift;
		while (defined $attribute ) {		
			$attributes { $attribute } = shift ;
			$attribute = shift;
		}
		if ( $element eq "label" && defined( $attributes{"define"}) ) {
			if ( $attributes { "define" } eq $label_searched ) {
				$found = 1 ;
				$OK_for_copy = 1 ;
				print OUT "<label"; 
				foreach $attribute ( keys( %attributes)) {
					print OUT " $attribute=\"" . $attributes{$attribute} . "\"";
				}
				print OUT ">\n";
 			}			
		}
		elsif ( $element eq "message" ){
			print OUT "<message"; 
			foreach $attribute ( keys( %attributes)) {
				print OUT " $attribute=\"" . $attributes{$attribute} . "\"";
			}
			print OUT ">"
		}
	}	
}
#-------------------------------------------------------------------------------
sub  char_hndl {
	if ( $OK_for_copy ) {
		my $expat = shift; 
		my $data = shift;
		
		$data =~ s/\s{2,}//;
		if ( $data ne ("" || "\n")) {
			print OUT "$data";
		}
	}
}
#-------------------------------------------------------------------------------
sub end_hndl {
	if ( $OK_for_copy ) {
		my $expat = shift; 
		my $element = shift;
		if ($element eq "label") {
			$OK_for_copy = 0;
			# to abort the parsing = go to the last label named AMAYA_MSG_MAX			
			$expat->finish ;
		}
		if ($element eq "label" || $element eq "message") { #just for security
			print OUT "</$element>\n";
		}
	}
}

#-------------------------------------------------------------------------------
sub default_hndl {
# don't do anything
}
#-------------------------------end of sub used by "search_and_recopy_a_label"-----------------------------------
#####################################################################################
1;
__END__
